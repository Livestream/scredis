<!DOCTYPE html >
<html>
        <head>
          <title>Client - scredis.Client</title>
          <meta name="description" content="Client - scredis.Client" />
          <meta name="keywords" content="Client scredis.Client" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../lib/template.js"></script>
      <script type="text/javascript" src="../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'scredis.Client';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a href="Client$.html" title="Go to companion"><img src="../lib/class_to_object_big.png" /></a>
        <p id="owner"><a href="package.html" class="extype" name="scredis">scredis</a></p>
        <h1><a href="Client$.html" title="Go to companion">Client</a></h1> <span class="permalink">
      <a href="../index.html#scredis.Client" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Client</span><span class="result"> extends <a href="io/AkkaNonBlockingConnection.html" class="extype" name="scredis.io.AkkaNonBlockingConnection">AkkaNonBlockingConnection</a> with <a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a> with <a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a> with <a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a> with <a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a> with <a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a> with <a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a> with <a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a> with <a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a> with <a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a> with <a href="commands/HyperLogLogCommands.html" class="extype" name="scredis.commands.HyperLogLogCommands">HyperLogLogCommands</a> with <a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a> with <a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Defines a Redis client supporting all non-blocking commands.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a>, <a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a>, <a href="commands/HyperLogLogCommands.html" class="extype" name="scredis.commands.HyperLogLogCommands">HyperLogLogCommands</a>, <a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a>, <a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a>, <a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a>, <a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a>, <a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a>, <a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a>, <a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a>, <a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a>, <a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a>, <a href="io/AkkaNonBlockingConnection.html" class="extype" name="scredis.io.AkkaNonBlockingConnection">AkkaNonBlockingConnection</a>, <a href="io/TransactionEnabledConnection.html" class="extype" name="scredis.io.TransactionEnabledConnection">TransactionEnabledConnection</a>, <a href="io/NonBlockingConnection.html" class="extype" name="scredis.io.NonBlockingConnection">NonBlockingConnection</a>, <a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a>, <span class="extype" name="com.typesafe.scalalogging.slf4j.LazyLogging">LazyLogging</span>, <span class="extype" name="com.typesafe.scalalogging.Logging">Logging</span>, <a href="io/Connection.html" class="extype" name="scredis.io.Connection">Connection</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scredis.Client"><span>Client</span></li><li class="in" name="scredis.commands.TransactionCommands"><span>TransactionCommands</span></li><li class="in" name="scredis.commands.PubSubCommands"><span>PubSubCommands</span></li><li class="in" name="scredis.commands.HyperLogLogCommands"><span>HyperLogLogCommands</span></li><li class="in" name="scredis.commands.ScriptingCommands"><span>ScriptingCommands</span></li><li class="in" name="scredis.commands.SortedSetCommands"><span>SortedSetCommands</span></li><li class="in" name="scredis.commands.SetCommands"><span>SetCommands</span></li><li class="in" name="scredis.commands.ListCommands"><span>ListCommands</span></li><li class="in" name="scredis.commands.HashCommands"><span>HashCommands</span></li><li class="in" name="scredis.commands.StringCommands"><span>StringCommands</span></li><li class="in" name="scredis.commands.KeyCommands"><span>KeyCommands</span></li><li class="in" name="scredis.commands.ServerCommands"><span>ServerCommands</span></li><li class="in" name="scredis.commands.ConnectionCommands"><span>ConnectionCommands</span></li><li class="in" name="scredis.io.AkkaNonBlockingConnection"><span>AkkaNonBlockingConnection</span></li><li class="in" name="scredis.io.TransactionEnabledConnection"><span>TransactionEnabledConnection</span></li><li class="in" name="scredis.io.NonBlockingConnection"><span>NonBlockingConnection</span></li><li class="in" name="scredis.io.AbstractAkkaConnection"><span>AbstractAkkaConnection</span></li><li class="in" name="com.typesafe.scalalogging.slf4j.LazyLogging"><span>LazyLogging</span></li><li class="in" name="com.typesafe.scalalogging.Logging"><span>Logging</span></li><li class="in" name="scredis.io.Connection"><span>Connection</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="scredis.Client#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(configName:String,path:String)(implicitsystem:akka.actor.ActorSystem):scredis.Client"></a>
      <a id="&lt;init&gt;:Client"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Client</span><span class="params">(<span name="configName">configName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="path">path: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="system">system: <span class="extype" name="akka.actor.ActorSystem">ActorSystem</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@&lt;init&gt;(configName:String,path:String)(implicitsystem:akka.actor.ActorSystem):scredis.Client" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a config file and using the provided path.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a config file and using the provided path.
</p></div><dl class="paramcmts block"><dt class="param">configName</dt><dd class="cmt"><p>config filename</p></dd><dt class="param">path</dt><dd class="cmt"><p>path pointing to the scredis config object</p></dd><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" class="extype" name="scredis.Client">scredis.Client</a>
</p></dd></dl><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>The path must include to the scredis object, e.g. x.y.scredis
</p></span></dd></dl></div>
    </li><li name="scredis.Client#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(configName:String)(implicitsystem:akka.actor.ActorSystem):scredis.Client"></a>
      <a id="&lt;init&gt;:Client"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Client</span><span class="params">(<span name="configName">configName: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="system">system: <span class="extype" name="akka.actor.ActorSystem">ActorSystem</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@&lt;init&gt;(configName:String)(implicitsystem:akka.actor.ActorSystem):scredis.Client" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a config file.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a config file.
</p></div><dl class="paramcmts block"><dt class="param">configName</dt><dd class="cmt"><p>config filename</p></dd><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" class="extype" name="scredis.Client">scredis.Client</a>
</p></dd></dl><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>The config file must contain the scredis object at its root.
This constructor is equivalent to </p><pre><span class="kw">new</span> Client(configName, <span class="lit">"scredis"</span>)</pre></span></dd></dl></div>
    </li><li name="scredis.Client#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(config:com.typesafe.config.Config)(implicitsystem:akka.actor.ActorSystem):scredis.Client"></a>
      <a id="&lt;init&gt;:Client"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Client</span><span class="params">(<span name="config">config: <span class="extype" name="com.typesafe.config.Config">Config</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="system">system: <span class="extype" name="akka.actor.ActorSystem">ActorSystem</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@&lt;init&gt;(config:com.typesafe.config.Config)(implicitsystem:akka.actor.ActorSystem):scredis.Client" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a com.typesafe.Config
</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a com.typesafe.Config
</p></div><dl class="paramcmts block"><dt class="param">config</dt><dd class="cmt"><p>com.typesafe.Config</p></dd><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" class="extype" name="scredis.Client">scredis.Client</a>
</p></dd></dl><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>The config must contain the scredis object at its root.
This constructor is equivalent to </p><pre><span class="kw">new</span> Client(config, <span class="lit">"scredis"</span>)</pre></span></dd></dl></div>
    </li><li name="scredis.Client#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(config:scredis.RedisConfig)(implicitsystem:akka.actor.ActorSystem):scredis.Client"></a>
      <a id="&lt;init&gt;:Client"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Client</span><span class="params">(<span name="config">config: <a href="RedisConfig.html" class="extype" name="scredis.RedisConfig">RedisConfig</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="system">system: <span class="extype" name="akka.actor.ActorSystem">ActorSystem</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@&lt;init&gt;(config:scredis.RedisConfig)(implicitsystem:akka.actor.ActorSystem):scredis.Client" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a <a href="RedisConfig.html" class="extype" name="scredis.RedisConfig">scredis.RedisConfig</a>
</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" class="extype" name="scredis.Client">scredis.Client</a> instance from a <a href="RedisConfig.html" class="extype" name="scredis.RedisConfig">scredis.RedisConfig</a>
</p></div><dl class="paramcmts block"><dt class="param">config</dt><dd class="cmt"><p><a href="RedisConfig.html" class="extype" name="scredis.RedisConfig">scredis.RedisConfig</a></p></dd><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" class="extype" name="scredis.Client">scredis.Client</a>
</p></dd></dl></div>
    </li><li name="scredis.Client#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(host:String,port:Int,passwordOpt:Option[String],database:Int,nameOpt:Option[String],connectTimeout:scala.concurrent.duration.FiniteDuration,receiveTimeoutOpt:Option[scala.concurrent.duration.FiniteDuration],maxWriteBatchSize:Int,tcpSendBufferSizeHint:Int,tcpReceiveBufferSizeHint:Int,akkaListenerDispatcherPath:String,akkaIODispatcherPath:String,akkaDecoderDispatcherPath:String)(implicitsystem:akka.actor.ActorSystem):scredis.Client"></a>
      <a id="&lt;init&gt;:Client"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Client</span><span class="params">(<span name="host">host: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol"><span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.Redis.Host</a></span></span></span>, <span name="port">port: <span class="extype" name="scala.Int">Int</span> = <span class="symbol"><span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.Redis.Port</a></span></span></span>, <span name="passwordOpt">passwordOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.Redis.PasswordOpt</a></span>'>...</span></span>, <span name="database">database: <span class="extype" name="scala.Int">Int</span> = <span class="symbol"><span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.Redis.Database</a></span></span></span>, <span name="nameOpt">nameOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol"><span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.Redis.NameOpt</a></span></span></span>, <span name="connectTimeout">connectTimeout: <span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.ConnectTimeout</a></span>'>...</span></span>, <span name="receiveTimeoutOpt">receiveTimeoutOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>] = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.ReceiveTimeoutOpt</a></span>'>...</span></span>, <span name="maxWriteBatchSize">maxWriteBatchSize: <span class="extype" name="scala.Int">Int</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.MaxWriteBatchSize</a></span>'>...</span></span>, <span name="tcpSendBufferSizeHint">tcpSendBufferSizeHint: <span class="extype" name="scala.Int">Int</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.TCPSendBufferSizeHint</a></span>'>...</span></span>, <span name="tcpReceiveBufferSizeHint">tcpReceiveBufferSizeHint: <span class="extype" name="scala.Int">Int</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.TCPReceiveBufferSizeHint</a></span>'>...</span></span>, <span name="akkaListenerDispatcherPath">akkaListenerDispatcherPath: <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.Akka.ListenerDispatcherPath</a></span>'>...</span></span>, <span name="akkaIODispatcherPath">akkaIODispatcherPath: <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.Akka.IODispatcherPath</a></span>'>...</span></span>, <span name="akkaDecoderDispatcherPath">akkaDecoderDispatcherPath: <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name='<span class="name"><a href="RedisConfigDefaults$.html">RedisConfigDefaults.IO.Akka.DecoderDispatcherPath</a></span>'>...</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="system">system: <span class="extype" name="akka.actor.ActorSystem">ActorSystem</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@&lt;init&gt;(host:String,port:Int,passwordOpt:Option[String],database:Int,nameOpt:Option[String],connectTimeout:scala.concurrent.duration.FiniteDuration,receiveTimeoutOpt:Option[scala.concurrent.duration.FiniteDuration],maxWriteBatchSize:Int,tcpSendBufferSizeHint:Int,tcpReceiveBufferSizeHint:Int,akkaListenerDispatcherPath:String,akkaIODispatcherPath:String,akkaDecoderDispatcherPath:String)(implicitsystem:akka.actor.ActorSystem):scredis.Client" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">host</dt><dd class="cmt"><p>server address</p></dd><dt class="param">port</dt><dd class="cmt"><p>server port</p></dd><dt class="param">passwordOpt</dt><dd class="cmt"><p>optional server password</p></dd><dt class="param">database</dt><dd class="cmt"><p>database index to select</p></dd><dt class="param">nameOpt</dt><dd class="cmt"><p>optional client name (available since 2.6.9)</p></dd><dt class="param">connectTimeout</dt><dd class="cmt"><p>connection timeout</p></dd><dt class="param">receiveTimeoutOpt</dt><dd class="cmt"><p>optional batch receive timeout</p></dd><dt class="param">maxWriteBatchSize</dt><dd class="cmt"><p>max number of bytes to send as part of a batch</p></dd><dt class="param">tcpSendBufferSizeHint</dt><dd class="cmt"><p>size hint of the tcp send buffer, in bytes</p></dd><dt class="param">tcpReceiveBufferSizeHint</dt><dd class="cmt"><p>size hint of the tcp receive buffer, in bytes</p></dd><dt class="param">akkaListenerDispatcherPath</dt><dd class="cmt"><p>path to listener dispatcher definition</p></dd><dt class="param">akkaIODispatcherPath</dt><dd class="cmt"><p>path to io dispatcher definition</p></dd><dt class="param">akkaDecoderDispatcherPath</dt><dd class="cmt"><p>path to decoder dispatcher definition</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@!=(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@##():Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@==(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#akkaDecoderDispatcherPath" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="akkaDecoderDispatcherPath:String"></a>
      <a id="akkaDecoderDispatcherPath:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">akkaDecoderDispatcherPath</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@akkaDecoderDispatcherPath:String" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#akkaIODispatcherPath" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="akkaIODispatcherPath:String"></a>
      <a id="akkaIODispatcherPath:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">akkaIODispatcherPath</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@akkaIODispatcherPath:String" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#akkaListenerDispatcherPath" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="akkaListenerDispatcherPath:String"></a>
      <a id="akkaListenerDispatcherPath:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">akkaListenerDispatcherPath</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@akkaListenerDispatcherPath:String" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#append" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="append[W](key:String,value:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="append[W](String,W)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">append</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.append.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.append.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@append[W](key:String,value:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Appends a value to a key.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to be appended</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value to append</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string after the append operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@asInstanceOf[T0]:T0" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scredis.commands.ConnectionCommands#auth" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="auth(password:String):scala.concurrent.Future[Unit]"></a>
      <a id="auth(String):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">auth</span><span class="params">(<span name="password">password: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@auth(password:String):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Authenticates to the server.</p><div class="fullcomment"><div class="comment cmt"><p>Authenticates to the server.
</p></div><dl class="paramcmts block"><dt class="param">password</dt><dd class="cmt"><p>the server password</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if authentication failed
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Use the empty string to re-authenticate with no password.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#bgRewriteAOF" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bgRewriteAOF():scala.concurrent.Future[Unit]"></a>
      <a id="bgRewriteAOF():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bgRewriteAOF</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@bgRewriteAOF():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Asynchronously rewrites the append-only file.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously rewrites the append-only file.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#bgSave" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bgSave():scala.concurrent.Future[Unit]"></a>
      <a id="bgSave():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bgSave</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@bgSave():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Asynchronously saves the dataset to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously saves the dataset to disk.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the background save is already in progress
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#bitCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitCount(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]"></a>
      <a id="bitCount(String,Long,Long):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitCount</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@bitCount(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Counts the number of bits set to 1 in a string from start offset to stop offset.</p><div class="fullcomment"><div class="comment cmt"><p>Counts the number of bits set to 1 in a string from start offset to stop offset.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key for which the bitcount should be returned</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (defaults to 0)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (defaults to -1)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of bits set to 1 in the specified interval</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Non-existent keys are treated as empty strings, so the command will return zero.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#bitOp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitOp(operation:scredis.BitOp,destKey:String,keys:String*):scala.concurrent.Future[Long]"></a>
      <a id="bitOp(BitOp,String,String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitOp</span><span class="params">(<span name="operation">operation: <a href="package$$BitOp.html" class="extype" name="scredis.BitOp">BitOp</a></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@bitOp(operation:scredis.BitOp,destKey:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Performs a bitwise operation between multiple strings.</p><div class="fullcomment"><div class="comment cmt"><p>Performs a bitwise operation between multiple strings.
</p></div><dl class="paramcmts block"><dt class="param">operation</dt><dd class="cmt"><p><a href="package$$BitOp.html" class="extype" name="scredis.BitOp">scredis.BitOp</a> to perform</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>destination key where the result of the operation will be stored</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to perform the operation upon</p></dd><dt>returns</dt><dd class="cmt"><p>the size of the string stored in the destination key, that is equal to the size of
the longest input string</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if at least one of the values stored at keys is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When an operation is performed between strings having different lengths, all the strings
shorter than the longest string in the set are treated as if they were zero-padded up to the
length of the longest string. The same holds true for non-existent keys, that are considered
as a stream of zero bytes up to the length of the longest string.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#bitPos" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitPos(key:String,bit:Boolean,start:Long,stop:Long):scala.concurrent.Future[Long]"></a>
      <a id="bitPos(String,Boolean,Long,Long):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitPos</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="bit">bit: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@bitPos(key:String,bit:Boolean,start:Long,stop:Long):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Return the position of the first bit set to 1 or 0 in a string.</p><div class="fullcomment"><div class="comment cmt"><p>Return the position of the first bit set to 1 or 0 in a string.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>string key</p></dd><dt class="param">bit</dt><dd class="cmt"><p>provide <b>true</b> to look for 1s and <b>false</b> to look for 0s</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset, in bytes</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset, in bytes</p></dd><dt>returns</dt><dd class="cmt"><p>the position of the first bit set to 1 or 0, according to the request</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.8.7
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The position is returned thinking at the string as an array of bits from left to right
where the first byte most significant bit is at position 0, the second byte most significant
big is at position 8 and so forth.</p><p>The range is interpreted as a range of bytes and not a range of bits, so start=0 and end=2
means to look at the first three bytes.</p><p>If we look for set bits (the bit argument is 1) and the string is empty or composed of just
zero bytes, -1 is returned.</p><p>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1,
the function returns the first bit not part of the string on the right. So if the string is
tree bytes set to the value 0xff the command BITPOS key 0 will return 24, since up to bit 23
all the bits are 1.</p><p>Basically the function consider the right of the string as padded with zeros if you look for
clear bits and specify no range or the start argument <b>only</b>.</p><p>However this behavior changes if you are looking for clear bits and specify a range with both
start and stop. If no clear bit is found in the specified range, the function returns -1 as
the user specified a clear range and there are no 0 bits in that range.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#clientGetName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientGetName():scala.concurrent.Future[Option[String]]"></a>
      <a id="clientGetName():Future[Option[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientGetName</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clientGetName():scala.concurrent.Future[Option[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Get the current client name.</p><div class="fullcomment"><div class="comment cmt"><p>Get the current client name.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>option containing the name if it has been set, <code>None</code> otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.9
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#clientKill" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientKill(ip:String,port:Int):scala.concurrent.Future[Unit]"></a>
      <a id="clientKill(String,Int):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientKill</span><span class="params">(<span name="ip">ip: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="port">port: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clientKill(ip:String,port:Int):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Kills the connection of a client.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the connection of a client.
</p></div><dl class="paramcmts block"><dt class="param">ip</dt><dd class="cmt"><p>ip address of the client to kill</p></dd><dt class="param">port</dt><dd class="cmt"><p>port of the client to kill</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the the client does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#clientKillWithFilters" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientKillWithFilters(addrOpt:Option[(String,Int)],idOpt:Option[Long],typeOpt:Option[scredis.ClientType],skipMe:Boolean):scala.concurrent.Future[Long]"></a>
      <a id="clientKillWithFilters(Option[(String,Int)],Option[Long],Option[ClientType],Boolean):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientKillWithFilters</span><span class="params">(<span name="addrOpt">addrOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>)] = <span class="symbol">None</span></span>, <span name="idOpt">idOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>] = <span class="symbol">None</span></span>, <span name="typeOpt">typeOpt: <span class="extype" name="scala.Option">Option</span>[<a href="package$$ClientType.html" class="extype" name="scredis.ClientType">ClientType</a>] = <span class="symbol">None</span></span>, <span name="skipMe">skipMe: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clientKillWithFilters(addrOpt:Option[(String,Int)],idOpt:Option[Long],typeOpt:Option[scredis.ClientType],skipMe:Boolean):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Kills the connection of potentially multiple clients satisfying various filters.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the connection of potentially multiple clients satisfying various filters.
</p></div><dl class="paramcmts block"><dt class="param">skipMe</dt><dd class="cmt"><p>when <b>true</b>, the calling client will not be killed, when <b>false</b>, the latter can
be killed</p></dd><dt>returns</dt><dd class="cmt"><p>the number of killed client(s)
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.12
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#clientList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientList():scala.concurrent.Future[List[Map[String,String]]]"></a>
      <a id="clientList():Future[List[Map[String,String]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientList</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clientList():scala.concurrent.Future[List[Map[String,String]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Lists all client connections.</p><div class="fullcomment"><div class="comment cmt"><p>Lists all client connections.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>list of clients
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#clientPause" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientPause(timeoutMillis:Long):scala.concurrent.Future[Unit]"></a>
      <a id="clientPause(Long):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientPause</span><span class="params">(<span name="timeoutMillis">timeoutMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clientPause(timeoutMillis:Long):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Suspends all clients for the specified amount of time.</p><div class="fullcomment"><div class="comment cmt"><p>Suspends all clients for the specified amount of time.
</p></div><dl class="paramcmts block"><dt class="param">timeoutMillis</dt><dd class="cmt"><p>the amount of time in milliseconds for which clients should be suspended</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.9.50
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the timeout is invalid
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#clientSetName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientSetName(name:String):scala.concurrent.Future[Unit]"></a>
      <a id="clientSetName(String):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientSetName</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clientSetName(name:String):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the current client name.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the current client name. If the empty string is provided, the name will be unset.
</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>name to associate the client to, if empty, unsets the client name
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.9
</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@clone():Object" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#command" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="command():scala.concurrent.Future[Map[String,scredis.CommandInfo]]"></a>
      <a id="command():Future[Map[String,CommandInfo]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">command</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <a href="package$$CommandInfo.html" class="extype" name="scredis.CommandInfo">CommandInfo</a>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@command():scala.concurrent.Future[Map[String,scredis.CommandInfo]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns details about all <code>Redis</code> commands.</p><div class="fullcomment"><div class="comment cmt"><p>Returns details about all <code>Redis</code> commands.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>map of command name to command info
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.13
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#commandCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="commandCount():scala.concurrent.Future[Int]"></a>
      <a id="commandCount():Future[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commandCount</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@commandCount():scala.concurrent.Future[Int]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the total number of commands in the target <code>Redis</code> server.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the total number of commands in the target <code>Redis</code> server.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>total number of commands
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.13
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#commandGetKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="commandGetKeys(command:String):scala.concurrent.Future[List[String]]"></a>
      <a id="commandGetKeys(String):Future[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commandGetKeys</span><span class="params">(<span name="command">command: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@commandGetKeys(command:String):scala.concurrent.Future[List[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the list of keys part of a full <code>Redis</code> command.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the list of keys part of a full <code>Redis</code> command.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the list of keys present in the command
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.13
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#commandInfo" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="commandInfo(names:String*):scala.concurrent.Future[Map[String,scredis.CommandInfo]]"></a>
      <a id="commandInfo(String*):Future[Map[String,CommandInfo]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commandInfo</span><span class="params">(<span name="names">names: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <a href="package$$CommandInfo.html" class="extype" name="scredis.CommandInfo">CommandInfo</a>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@commandInfo(names:String*):scala.concurrent.Future[Map[String,scredis.CommandInfo]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns details about the specified <code>Redis</code> commands.</p><div class="fullcomment"><div class="comment cmt"><p>Returns details about the specified <code>Redis</code> commands.
</p></div><dl class="paramcmts block"><dt class="param">names</dt><dd class="cmt"><p>command names</p></dd><dt>returns</dt><dd class="cmt"><p>map of command name to command info
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.13
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#configGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configGet(pattern:String):scala.concurrent.Future[Map[String,String]]"></a>
      <a id="configGet(String):Future[Map[String,String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configGet</span><span class="params">(<span name="pattern">pattern: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;*&quot;</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@configGet(pattern:String):scala.concurrent.Future[Map[String,String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Gets the value of a configuration parameter.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the value of a configuration parameter.
</p></div><dl class="paramcmts block"><dt class="param">pattern</dt><dd class="cmt"><p>name or pattern of the configuration parameter to get</p></dd><dt>returns</dt><dd class="cmt"><p>option containing the matched parameters, or <code>None</code> if no parameters are matched
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#configResetStat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configResetStat():scala.concurrent.Future[Unit]"></a>
      <a id="configResetStat():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configResetStat</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@configResetStat():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Resets the stats returned by INFO.</p><div class="fullcomment"><div class="comment cmt"><p>Resets the stats returned by INFO.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#configRewrite" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configRewrite():scala.concurrent.Future[Unit]"></a>
      <a id="configRewrite():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configRewrite</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@configRewrite():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Rewrites the redis.conf file the server was started with, applying the minimal changes
needed to make it reflect the configuration currently used by the server, which may be
different compared to the original one because of the use of the CONFIG SET command.</p><div class="fullcomment"><div class="comment cmt"><p>Rewrites the redis.conf file the server was started with, applying the minimal changes
needed to make it reflect the configuration currently used by the server, which may be
different compared to the original one because of the use of the CONFIG SET command.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the configuration file was not properly written
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#configSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configSet[W](parameter:String,value:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="configSet[W](String,W)(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="parameter">parameter: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.ServerCommands.configSet.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ServerCommands.configSet.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@configSet[W](parameter:String,value:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets a configuration parameter to the given value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a configuration parameter to the given value.
</p></div><dl class="paramcmts block"><dt class="param">parameter</dt><dd class="cmt"><p>parameter's name</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set parameter to</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the parameter could not be set
</p></span></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#connectTimeout" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="connectTimeout:scala.concurrent.duration.FiniteDuration"></a>
      <a id="connectTimeout:FiniteDuration"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">connectTimeout</span><span class="result">: <span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@connectTimeout:scala.concurrent.duration.FiniteDuration" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#database" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="database:Int"></a>
      <a id="database:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">database</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@database:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#dbSize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbSize():scala.concurrent.Future[Long]"></a>
      <a id="dbSize():Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbSize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@dbSize():scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Return the number of keys in the selected database.</p><div class="fullcomment"><div class="comment cmt"><p>Return the number of keys in the selected database.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>number of keys in the selected database
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#decodersCount" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="decodersCount:Int"></a>
      <a id="decodersCount:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">decodersCount</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@decodersCount:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#decr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="decr(key:String):scala.concurrent.Future[Long]"></a>
      <a id="decr(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">decr</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@decr(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Decrements the integer value of a key by one.</p><div class="fullcomment"><div class="comment cmt"><p>Decrements the integer value of a key by one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to decrement</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type or contains a string that cannot be
represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#decrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="decrBy(key:String,decrement:Long):scala.concurrent.Future[Long]"></a>
      <a id="decrBy(String,Long):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">decrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="decrement">decrement: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@decrBy(key:String,decrement:Long):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Decrements the integer value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Decrements the integer value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to decrement</p></dd><dt class="param">decrement</dt><dd class="cmt"><p>the decrement</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type or contains
a string that cannot be represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#del" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="del(keys:String*):scala.concurrent.Future[Long]"></a>
      <a id="del(String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">del</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@del(keys:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Deletes one or multiple keys.</p><div class="fullcomment"><div class="comment cmt"><p>Deletes one or multiple keys.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>key(s) to delete</p></dd><dt>returns</dt><dd class="cmt"><p>the number of keys that were deleted
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>a key is ignored if it does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#dump" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dump(key:String):scala.concurrent.Future[Option[Array[Byte]]]"></a>
      <a id="dump(String):Future[Option[Array[Byte]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dump</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@dump(key:String):scala.concurrent.Future[Option[Array[Byte]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a serialized version of the value stored at the specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a serialized version of the value stored at the specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to dump</p></dd><dt>returns</dt><dd class="cmt"><p>the serialized value or <code>None</code> if the key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#ec" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ec:scala.concurrent.ExecutionContextExecutor"></a>
      <a id="ec:ExecutionContextExecutor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ec</span><span class="result">: <span class="extype" name="scala.concurrent.ExecutionContextExecutor">ExecutionContextExecutor</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@ec:scala.concurrent.ExecutionContextExecutor" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a> → <a href="io/Connection.html" class="extype" name="scredis.io.Connection">Connection</a></dd></dl></div>
    </li><li name="scredis.commands.ConnectionCommands#echo" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="echo(message:String):scala.concurrent.Future[String]"></a>
      <a id="echo(String):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">echo</span><span class="params">(<span name="message">message: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@echo(message:String):scala.concurrent.Future[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Echoes the given string on the server.</p><div class="fullcomment"><div class="comment cmt"><p>Echoes the given string on the server.
</p></div><dl class="paramcmts block"><dt class="param">message</dt><dd class="cmt"><p>the message to echo</p></dd><dt>returns</dt><dd class="cmt"><p>the echoed message
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@eq(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@equals(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.ScriptingCommands#eval" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eval[R,W1,W2](script:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$1:scredis.protocol.Decoder[R],implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]"></a>
      <a id="eval[R,W1,W2](String,Seq[W1],Seq[W2])(Decoder[R],Writer[W1],Writer[W2]):Future[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eval</span><span class="tparams">[<span name="R">R</span>, <span name="W1">W1</span>, <span name="W2">W2</span>]</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scredis.commands.ScriptingCommands.eval.W1">W1</span>] = <span class="symbol">Nil</span></span>, <span name="args">args: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scredis.commands.ScriptingCommands.eval.W2">W2</span>] = <span class="symbol">Nil</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="protocol/package.html#Decoder[X]=PartialFunction[scredis.protocol.Response,X]" class="extmbr" name="scredis.protocol.Decoder">Decoder</a>[<span class="extype" name="scredis.commands.ScriptingCommands.eval.R">R</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ScriptingCommands.eval.W1">W1</span>]</span>, <span name="arg2">arg2: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ScriptingCommands.eval.W2">W2</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.ScriptingCommands.eval.R">R</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@eval[R,W1,W2](script:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$1:scredis.protocol.Decoder[R],implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Executes a Lua script that does not require any keys or arguments.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a Lua script that does not require any keys or arguments.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>the LUA script</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if an error occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the result could not be decoded by provided <code>Decoder</code>
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ScriptingCommands#evalSHA" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalSHA[R,W1,W2](sha1:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$4:scredis.protocol.Decoder[R],implicitevidence$5:scredis.serialization.Writer[W1],implicitevidence$6:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]"></a>
      <a id="evalSHA[R,W1,W2](String,Seq[W1],Seq[W2])(Decoder[R],Writer[W1],Writer[W2]):Future[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalSHA</span><span class="tparams">[<span name="R">R</span>, <span name="W1">W1</span>, <span name="W2">W2</span>]</span><span class="params">(<span name="sha1">sha1: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scredis.commands.ScriptingCommands.evalSHA.W1">W1</span>] = <span class="symbol">Nil</span></span>, <span name="args">args: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scredis.commands.ScriptingCommands.evalSHA.W2">W2</span>] = <span class="symbol">Nil</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="protocol/package.html#Decoder[X]=PartialFunction[scredis.protocol.Response,X]" class="extmbr" name="scredis.protocol.Decoder">Decoder</a>[<span class="extype" name="scredis.commands.ScriptingCommands.evalSHA.R">R</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ScriptingCommands.evalSHA.W1">W1</span>]</span>, <span name="arg2">arg2: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ScriptingCommands.evalSHA.W2">W2</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.ScriptingCommands.evalSHA.R">R</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@evalSHA[R,W1,W2](sha1:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$4:scredis.protocol.Decoder[R],implicitevidence$5:scredis.serialization.Writer[W1],implicitevidence$6:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Executes a cached Lua script that does not require any keys or arguments by its SHA1 digest.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a cached Lua script that does not require any keys or arguments by its SHA1 digest.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if there is no script corresponding to the provided SHA1 digest or if an error
occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the result could not be decoded by provided <code>Decoder</code>
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#exists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exists(key:String):scala.concurrent.Future[Boolean]"></a>
      <a id="exists(String):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@exists(key:String):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Determines if a key exists.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a key exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to check for existence</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the key exists, <b>false</b> otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#expire" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expire(key:String,ttlSeconds:Int):scala.concurrent.Future[Boolean]"></a>
      <a id="expire(String,Int):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expire</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="ttlSeconds">ttlSeconds: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@expire(key:String,ttlSeconds:Int):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets a key's time to live in seconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live in seconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttlSeconds</dt><dd class="cmt"><p>time-to-live in seconds</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#expireAt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expireAt(key:String,timestamp:Long):scala.concurrent.Future[Boolean]"></a>
      <a id="expireAt(String,Long):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expireAt</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="timestamp">timestamp: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@expireAt(key:String,timestamp:Long):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the expiration for a key as a UNIX timestamp.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expiration for a key as a UNIX timestamp.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">timestamp</dt><dd class="cmt"><p>UNIX timestamp at which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@finalize():Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#flushAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flushAll():scala.concurrent.Future[Unit]"></a>
      <a id="flushAll():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flushAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@flushAll():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes all keys from all databases.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all keys from all databases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#flushDB" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flushDB():scala.concurrent.Future[Unit]"></a>
      <a id="flushDB():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flushDB</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@flushDB():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes all keys from the current database.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all keys from the current database.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#get" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="get[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="get[R](String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">get</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.StringCommands.get.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.StringCommands.get.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@get[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p>value stored at key, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#getBit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getBit(key:String,offset:Long):scala.concurrent.Future[Boolean]"></a>
      <a id="getBit(String,Long):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getBit</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getBit(key:String,offset:Long):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the bit value at offset in the string value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the bit value at offset in the string value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">offset</dt><dd class="cmt"><p>the position in the string</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the bit is set to 1, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getClass():Class[_]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#getDatabase" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getDatabase:Int"></a>
      <a id="getDatabase:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getDatabase</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getDatabase:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#getNameOpt" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getNameOpt:Option[String]"></a>
      <a id="getNameOpt:Option[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getNameOpt</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getNameOpt:Option[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#getPasswordOpt" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getPasswordOpt:Option[String]"></a>
      <a id="getPasswordOpt:Option[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getPasswordOpt</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getPasswordOpt:Option[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#getRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getRange[R](key:String,start:Long,stop:Long)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[R]"></a>
      <a id="getRange[R](String,Long,Long)(Reader[R]):Future[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.StringCommands.getRange.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.StringCommands.getRange.R">R</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getRange[R](key:String,start:Long,stop:Long)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[R]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a substring of the string stored at a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a substring of the string stored at a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>the stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the substring determined by the specified offsets, or the empty string if the key
does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both offsets are inclusive, i.e. [start, stop]. The function handles out of range
requests by limiting the resulting range to the actual length of the string.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#getSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getSet[R,W](key:String,value:W)(implicitevidence$4:scredis.serialization.Reader[R],implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[R]]"></a>
      <a id="getSet[R,W](String,W)(Reader[R],Writer[W]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getSet</span><span class="tparams">[<span name="R">R</span>, <span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.getSet.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.StringCommands.getSet.R">R</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.getSet.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.StringCommands.getSet.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@getSet[R,W](key:String,value:W)(implicitevidence$4:scredis.serialization.Reader[R],implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the string value of a key and return its old value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a key and return its old value.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value to set key to</p></dd><dt>returns</dt><dd class="cmt"><p>the old value, or <code>None</code> if the latter did not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hDel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hDel(key:String,fields:String*):scala.concurrent.Future[Long]"></a>
      <a id="hDel(String,String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hDel</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fields">fields: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hDel(key:String,fields:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Deletes one or more hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Deletes one or more hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of the hash</p></dd><dt class="param">fields</dt><dd class="cmt"><p>field(s) to be deleted from hash</p></dd><dt>returns</dt><dd class="cmt"><p>the number of fields that were removed from the hash, not including specified but non
existing fields</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Specified fields that do not exist within this hash are ignored. If key does not exist,
it is treated as an empty hash and this command returns 0. Redis versions older than 2.4 can
only remove a field per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hExists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hExists(key:String,field:String):scala.concurrent.Future[Boolean]"></a>
      <a id="hExists(String,String):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hExists</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hExists(key:String,field:String):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Determines if a hash field exists.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a hash field exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>name of the field</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the hash contains field, <b>false</b> if the hash does not contain it or
the key does not exists</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hGet[R](key:String,field:String)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="hGet[R](String,String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hGet</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.HashCommands.hGet.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.HashCommands.hGet.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hGet[R](key:String,field:String)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the value of a hash field.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value of a hash field.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>the value associated with field name, or <code>None</code> when field is not present in the hash
or key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hGetAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hGetAll[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[Map[String,R]]]"></a>
      <a id="hGetAll[R](String)(Reader[R]):Future[Option[Map[String,R]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hGetAll</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.HashCommands.hGetAll.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.HashCommands.hGetAll.R">R</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hGetAll[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[Map[String,R]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns all the fields and values in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the fields and values in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>key-value pairs stored in hash with key, or <code>None</code> when hash is empty or key does not
exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hIncrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hIncrBy(key:String,field:String,count:Long):scala.concurrent.Future[Long]"></a>
      <a id="hIncrBy(String,String,Long):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hIncrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hIncrBy(key:String,field:String,count:Long):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Increments the integer value of a hash field by the given number.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a hash field by the given number.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value at field after the increment operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the field does not hold an integer value or if the value stored at key is not of
type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, a new key holding a hash is created. If field does not exist the
value is set to 0 before the operation is performed.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hIncrByFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hIncrByFloat(key:String,field:String,count:Double):scala.concurrent.Future[Double]"></a>
      <a id="hIncrByFloat(String,String,Double):Future[Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hIncrByFloat</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hIncrByFloat(key:String,field:String,count:Double):scala.concurrent.Future[Double]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Increments the float value of a hash field by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the float value of a hash field by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value at field after the increment operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the field does not hold a floating point value or if the value stored at key is
not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, a new key holding a hash is created. If field does not exist the
value is set to 0 before the operation is performed.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hKeys(key:String):scala.concurrent.Future[Set[String]]"></a>
      <a id="hKeys(String):Future[Set[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hKeys</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hKeys(key:String):scala.concurrent.Future[Set[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns all the fields in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the fields in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>set of field names or the empty set if the hash is empty or the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hLen(key:String):scala.concurrent.Future[Long]"></a>
      <a id="hLen(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hLen(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of fields contained in the hash stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of fields contained in the hash stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>number of fields in the hash, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hScan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,List[(String,R)])]"></a>
      <a id="hScan[R](String,Long,Option[String],Option[Int])(Reader[R]):Future[(Long,List[(String,R)])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="cursor">cursor: <span class="extype" name="scala.Long">Long</span></span>, <span name="matchOpt">matchOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.HashCommands.hScan.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.List">List</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.HashCommands.hScan.R">R</span>)])]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,List[(String,R)])]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Incrementally iterates through the fields of a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates through the fields of a hash.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the list of fields
(key-value pairs) as its second element
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hSet[W](key:String,field:String,value:W)(implicitevidence$7:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="hSet[W](String,String,W)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.HashCommands.hSet.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.HashCommands.hSet.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hSet[W](key:String,field:String,value:W)(implicitevidence$7:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the string value of a hash field.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a hash field.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if field is a new field in the hash and value was set, <b>false</b> if
field already exists and the value was updated</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the field already exists in the hash, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hSetNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hSetNX[W](key:String,field:String,value:W)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="hSetNX[W](String,String,W)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hSetNX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.HashCommands.hSetNX.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.HashCommands.hSetNX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hSetNX[W](key:String,field:String,value:W)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the value of a hash field, only if the field does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of a hash field, only if the field does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if field is a new field in the hash and value was set, <b>false</b> if
field already exists and no operation was performed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hVals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hVals[R](key:String)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]"></a>
      <a id="hVals[R](String)(Reader[R]):Future[List[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hVals</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.HashCommands.hVals.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scredis.commands.HashCommands.hVals.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hVals[R](key:String)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns all the values in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the values in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>list of values, or the empty list if hash is empty or key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hashCode():Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hmGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmGet[R](key:String,fields:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]"></a>
      <a id="hmGet[R](String,String*)(Reader[R]):Future[List[Option[R]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmGet</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fields">fields: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.HashCommands.hmGet.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.HashCommands.hmGet.R">R</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hmGet[R](key:String,fields:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the values associated to the specified hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the values associated to the specified hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fields</dt><dd class="cmt"><p>field(s) to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>list of value(s) associated to the specified field name(s)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>For every field that does not exist, <code>None</code> is returned.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hmGetAsMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmGetAsMap[R](key:String,fields:String*)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]"></a>
      <a id="hmGetAsMap[R](String,String*)(Reader[R]):Future[Map[String,R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmGetAsMap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fields">fields: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.HashCommands.hmGetAsMap.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.HashCommands.hmGetAsMap.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hmGetAsMap[R](key:String,fields:String*)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a <code>Map</code> containing field-value pairs associated to the specified hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Map</code> containing field-value pairs associated to the specified hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fields</dt><dd class="cmt"><p>field(s) to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>field-value pairs associated to the specified field name(s)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Every non-existent field gets removed from the resulting <code>Map</code>.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HashCommands#hmSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmSet[W](key:String,fieldValuePairs:Map[String,W])(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="hmSet[W](String,Map[String,W])(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fieldValuePairs">fieldValuePairs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.HashCommands.hmSet.W">W</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.HashCommands.hmSet.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@hmSet[W](key:String,fieldValuePairs:Map[String,W])(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets multiple hash fields to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Sets multiple hash fields to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fieldValuePairs</dt><dd class="cmt"><p>field-value pair(s) to be set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This command overwrites any existing fields in the hash. If key does not exist, a new
key holding a hash is created
</p></span></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#host" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="host:String"></a>
      <a id="host:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">host</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@host:String" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.TransactionCommands#inTransaction" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inTransaction(f:scredis.TransactionBuilder=&gt;Any):scala.concurrent.Future[IndexedSeq[scala.util.Try[Any]]]"></a>
      <a id="inTransaction((TransactionBuilder)⇒Any):Future[IndexedSeq[Try[Any]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inTransaction</span><span class="params">(<span name="f">f: (<a href="TransactionBuilder.html" class="extype" name="scredis.TransactionBuilder">TransactionBuilder</a>) ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.IndexedSeq">IndexedSeq</span>[<span class="extype" name="scala.util.Try">Try</span>[<span class="extype" name="scala.Any">Any</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@inTransaction(f:scredis.TransactionBuilder=&gt;Any):scala.concurrent.Future[IndexedSeq[scala.util.Try[Any]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#incr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="incr(key:String):scala.concurrent.Future[Long]"></a>
      <a id="incr(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">incr</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@incr(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Increments the integer value of a key by one.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a key by one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the increment</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type or contains a string that cannot be
represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#incrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="incrBy(key:String,increment:Long):scala.concurrent.Future[Long]"></a>
      <a id="incrBy(String,Long):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">incrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="increment">increment: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@incrBy(key:String,increment:Long):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Increments the integer value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt class="param">increment</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type or contains
a string that cannot be represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#incrByFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="incrByFloat(key:String,increment:Double):scala.concurrent.Future[Double]"></a>
      <a id="incrByFloat(String,Double):Future[Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">incrByFloat</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="increment">increment: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@incrByFloat(key:String,increment:Double):scala.concurrent.Future[Double]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Increment the float value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increment the float value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt class="param">increment</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type, the current key content or the
specified increment are not parseable as a double precision floating point number
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#info" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="info(section:String):scala.concurrent.Future[Map[String,String]]"></a>
      <a id="info(String):Future[Map[String,String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">info</span><span class="params">(<span name="section">section: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;default&quot;</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@info(section:String):scala.concurrent.Future[Map[String,String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Gets information and statistics about the server.</p><div class="fullcomment"><div class="comment cmt"><p>Gets information and statistics about the server.
</p></div><dl class="paramcmts block"><dt class="param">section</dt><dd class="cmt"><p>name of the section for which data should be retrieved</p></dd><dt>returns</dt><dd class="cmt"><p>map of field -&gt; value pairs that match the specified section, or an empty map
if the section does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>The section can additionally take the following values: <code>all</code> and <code>default</code>.
</p></span></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@isInstanceOf[T0]:Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#isShuttingDown" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isShuttingDown:Boolean"></a>
      <a id="isShuttingDown:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">isShuttingDown</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@isShuttingDown:Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#keys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="keys(pattern:String):scala.concurrent.Future[Set[String]]"></a>
      <a id="keys(String):Future[Set[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">keys</span><span class="params">(<span name="pattern">pattern: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@keys(pattern:String):scala.concurrent.Future[Set[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Finds all keys matching the given pattern.</p><div class="fullcomment"><div class="comment cmt"><p>Finds all keys matching the given pattern.
</p></div><dl class="paramcmts block"><dt class="param">pattern</dt><dd class="cmt"><p>pattern to search for</p></dd><dt>returns</dt><dd class="cmt"><p>the matched keys, or the empty set if no keys match the given pattern
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lIndex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lIndex[R](key:String,index:Long)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="lIndex[R](String,Long)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lIndex</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="index">index: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.ListCommands.lIndex.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.ListCommands.lIndex.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lIndex[R](key:String,index:Long)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns an element from a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an element from a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>zero-based position in the list</p></dd><dt>returns</dt><dd class="cmt"><p>the requested element, or <code>None</code> when index is out of range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The index is zero-based, so 0 means the first element, 1 the second element and so on.
Negative indices can be used to designate elements starting at the tail of the list.
Here, -1 means the last element, -2 means the penultimate and so forth.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lInsert" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsert[W1,W2](key:String,position:scredis.Position,pivot:W1,value:W2)(implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsert[W1,W2](String,Position,W1,W2)(Writer[W1],Writer[W2]):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsert</span><span class="tparams">[<span name="W1">W1</span>, <span name="W2">W2</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="position">position: <a href="package$$Position.html" class="extype" name="scredis.Position">Position</a></span>, <span name="pivot">pivot: <span class="extype" name="scredis.commands.ListCommands.lInsert.W1">W1</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.ListCommands.lInsert.W2">W2</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.lInsert.W1">W1</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.lInsert.W2">W2</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lInsert[W1,W2](key:String,position:scredis.Position,pivot:W1,value:W2)(implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[Option[Long]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Inserts an element before or after another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element before or after another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lLen(key:String):scala.concurrent.Future[Long]"></a>
      <a id="lLen(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lLen(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the length of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list at key, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPop[R](key:String)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="lPop[R](String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPop</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.ListCommands.lPop.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.ListCommands.lPop.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lPop[R](key:String)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes and returns the first element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the first element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPush[W](key:String,values:W*)(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="lPush[W](String,W*)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPush</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="values">values: <span class="extype" name="scredis.commands.ListCommands.lPush.W">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.lPush.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lPush[W](key:String,values:W*)(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Prepends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">values</dt><dd class="cmt"><p>value(s) to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lPushX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPushX[W](key:String,value:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="lPushX[W](String,W)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPushX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.ListCommands.lPushX.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.lPushX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lPushX[W](key:String,value:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Prepends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lRange[R](key:String,start:Long,stop:Long)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]"></a>
      <a id="lRange[R](String,Long,Long)(Reader[R]):Future[List[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.ListCommands.lRange.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scredis.commands.ListCommands.lRange.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lRange[R](key:String,start:Long,stop:Long)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of elements from a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of elements from a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>list of elements in the specified range, or the empty list if there are no such
elements or the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The offsets start and end are zero-based indexes, with 0 being the first element of the
list (the head of the list), 1 being the next element and so on. These offsets can also be
negative numbers indicating offsets starting at the end of the list. For example, -1 is the
last element of the list, -2 the penultimate, and so on. Both offsets are inclusive, i.e.
LRANGE key 0 10 will return 11 elements (if they exist).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lRem[W](key:String,value:W,count:Int)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="lRem[W](String,W,Int)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lRem</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.ListCommands.lRem.W">W</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.lRem.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lRem[W](key:String,value:W,count:Int)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes the first count occurrences of elements equal to value from the list stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the first count occurrences of elements equal to value from the list stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be removed from the list</p></dd><dt class="param">count</dt><dd class="cmt"><p>indicates the number of found values that should be removed, see above note</p></dd><dt>returns</dt><dd class="cmt"><p>the number of removed elements</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The count argument influences the operation in the following ways:</p><pre>count &gt; <span class="num">0</span>: Remove elements equal to value moving from head to tail.
count &lt; <span class="num">0</span>: Remove elements equal to value moving from tail to head.
count = <span class="num">0</span>: Remove all elements equal to value.</pre></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lSet[W](key:String,index:Long,value:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="lSet[W](String,Long,W)(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="index">index: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.ListCommands.lSet.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.lSet.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lSet[W](key:String,index:Long,value:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the value of an element in a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of an element in a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>position of the element to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be set at index</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if index is out of range or if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#lTrim" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lTrim(key:String,start:Long,stop:Long):scala.concurrent.Future[Unit]"></a>
      <a id="lTrim(String,Long,Long):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lTrim</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lTrim(key:String,start:Long,stop:Long):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Trims a list to the specified range.</p><div class="fullcomment"><div class="comment cmt"><p>Trims a list to the specified range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Out of range indexes will not produce an error: if start is larger than the end of the
list, or start &gt; end, the result will be an empty list (which causes key to be removed). If
end is larger than the end of the list, Redis will treat it like the last element of the list.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#lastSave" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lastSave():scala.concurrent.Future[Long]"></a>
      <a id="lastSave():Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lastSave</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@lastSave():scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Gets the UNIX timestamp of the last successful save to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the UNIX timestamp of the last successful save to disk.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>UNIX timestamp
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.io.AkkaNonBlockingConnection#listenerActor" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="listenerActor:akka.actor.ActorRef"></a>
      <a id="listenerActor:ActorRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">listenerActor</span><span class="result">: <span class="extype" name="akka.actor.ActorRef">ActorRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@listenerActor:akka.actor.ActorRef" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AkkaNonBlockingConnection.html" class="extype" name="scredis.io.AkkaNonBlockingConnection">AkkaNonBlockingConnection</a></dd></dl></div>
    </li><li name="com.typesafe.scalalogging.slf4j.LazyLogging#logger" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="logger:com.typesafe.scalalogging.slf4j.Logger"></a>
      <a id="logger:Logger"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">logger</span><span class="result">: <span class="extype" name="com.typesafe.scalalogging.slf4j.Logger">Logger</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@logger:com.typesafe.scalalogging.slf4j.Logger" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>LazyLogging → Logging</dd></dl></div>
    </li><li name="scredis.commands.StringCommands#mGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mGet[R](keys:String*)(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]"></a>
      <a id="mGet[R](String*)(Reader[R]):Future[List[Option[R]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mGet</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.StringCommands.mGet.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.StringCommands.mGet.R">R</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@mGet[R](keys:String*)(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the values of all specified keys.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the values of all specified keys.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>the keys to fetch</p></dd><dt>returns</dt><dd class="cmt"><p>list of value(s) stored at the specified key(s)
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>For every key that does not hold a string value or does not exist, <code>None</code> is returned.
Because of this, the operation never fails.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#mGetAsMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mGetAsMap[R](keys:String*)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]"></a>
      <a id="mGetAsMap[R](String*)(Reader[R]):Future[Map[String,R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mGetAsMap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.StringCommands.mGetAsMap.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.StringCommands.mGetAsMap.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@mGetAsMap[R](keys:String*)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a <code>Map</code> containing the specified key(s) paired to their respective value(s).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Map</code> containing the specified key(s) paired to their respective value(s).
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>the keys to fetch</p></dd><dt>returns</dt><dd class="cmt"><p>map of key-value pairs
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>Every key that does not hold a string value or does not exist will be removed from the
resulting <code>Map</code>.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#mSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mSet[W](keyValuePairs:Map[String,W])(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="mSet[W](Map[String,W])(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="keyValuePairs">keyValuePairs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.StringCommands.mSet.W">W</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.mSet.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@mSet[W](keyValuePairs:Map[String,W])(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Atomically sets multiple keys to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">keyValuePairs</dt><dd class="cmt"><p>map of key-value pairs to set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.1
</p></dd><dt>Note</dt><dd><span class="cmt"><p>MSET replaces existing values with new values, just as regular SET.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#mSetNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mSetNX[W](keyValuePairs:Map[String,W])(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="mSetNX[W](Map[String,W])(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mSetNX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="keyValuePairs">keyValuePairs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.StringCommands.mSetNX.W">W</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.mSetNX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@mSetNX[W](keyValuePairs:Map[String,W])(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Atomically sets multiple keys to multiple values, only if none of the keys exist.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values, only if none of the keys exist.
</p></div><dl class="paramcmts block"><dt class="param">keyValuePairs</dt><dd class="cmt"><p>map of key-value pairs to set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if all the keys were set, <b>false</b> if at least one key already existed and thus
no operation was performed.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.1
</p></dd><dt>Note</dt><dd><span class="cmt"><p>MSETNX will not perform any operation at all even if just a single key already exists.
</p></span></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#maxWriteBatchSize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="maxWriteBatchSize:Int"></a>
      <a id="maxWriteBatchSize:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">maxWriteBatchSize</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@maxWriteBatchSize:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#migrate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="migrate(key:String,host:String,port:Int,database:Int,timeout:scala.concurrent.duration.FiniteDuration,copy:Boolean,replace:Boolean):scala.concurrent.Future[Unit]"></a>
      <a id="migrate(String,String,Int,Int,FiniteDuration,Boolean,Boolean):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">migrate</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="host">host: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="port">port: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">6379</span></span>, <span name="database">database: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>, <span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span> = <span class="symbol">2 seconds</span></span>, <span name="copy">copy: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="replace">replace: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@migrate(key:String,host:String,port:Int,database:Int,timeout:scala.concurrent.duration.FiniteDuration,copy:Boolean,replace:Boolean):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Atomically transfers a key from a Redis instance to another one.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically transfers a key from a Redis instance to another one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to transfer</p></dd><dt class="param">host</dt><dd class="cmt"><p>destination host</p></dd><dt class="param">port</dt><dd class="cmt"><p>destination port</p></dd><dt class="param">database</dt><dd class="cmt"><p>destination database</p></dd><dt class="param">timeout</dt><dd class="cmt"><p>timeout duration, up to milliseconds precision</p></dd><dt class="param">copy</dt><dd class="cmt"><p>if <b>true</b>, do not remove the key from the local instance</p></dd><dt class="param">replace</dt><dd class="cmt"><p>if <b>true</b>, replace existing key on the remote instance</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if an error occurs
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#move" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="move(key:String,database:Int):scala.concurrent.Future[Boolean]"></a>
      <a id="move(String,Int):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">move</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="database">database: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@move(key:String,database:Int):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Moves a key to another database.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a key to another database.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to move</p></dd><dt class="param">database</dt><dd class="cmt"><p>destination database</p></dd><dt>returns</dt><dd class="cmt"><p>true if key was moved, false otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#nameOpt" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nameOpt:Option[String]"></a>
      <a id="nameOpt:Option[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">nameOpt</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@nameOpt:Option[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@ne(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@notify():Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@notifyAll():Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#objectEncoding" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="objectEncoding(key:String):scala.concurrent.Future[Option[String]]"></a>
      <a id="objectEncoding(String):Future[Option[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">objectEncoding</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@objectEncoding(key:String):scala.concurrent.Future[Option[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the kind of internal representation used in order to store the value associated with
a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the kind of internal representation used in order to store the value associated with
a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key</p></dd><dt>returns</dt><dd class="cmt"><p>the object encoding or <code>None</code> if the key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.3
</p></dd><dt>Note</dt><dd><span class="cmt"><p>Objects can be encoded in different ways:
Strings can be encoded as <code>raw</code> or <code>int</code>
Lists can be encoded as <code>ziplist</code> or <code>linkedlist</code>
Sets can be encoded as <code>intset</code> or <code>hashtable</code>
Hashes can be encoded as <code>zipmap</code> or <code>hashtable</code>
SortedSets can be encoded as <code>ziplist</code> or <code>skiplist</code>
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#objectIdleTime" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="objectIdleTime(key:String):scala.concurrent.Future[Option[Long]]"></a>
      <a id="objectIdleTime(String):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">objectIdleTime</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@objectIdleTime(key:String):scala.concurrent.Future[Option[Long]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of seconds since the object stored at the specified key is idle (not
requested by read or write operations).</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of seconds since the object stored at the specified key is idle (not
requested by read or write operations).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key</p></dd><dt>returns</dt><dd class="cmt"><p>the number of seconds since the object is idle or <code>None</code> if the key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.3
</p></dd><dt>Note</dt><dd><span class="cmt"><p>While the value is returned in seconds the actual resolution of this timer is
10 seconds, but may vary in future implementations.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#objectRefCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="objectRefCount(key:String):scala.concurrent.Future[Option[Long]]"></a>
      <a id="objectRefCount(String):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">objectRefCount</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@objectRefCount(key:String):scala.concurrent.Future[Option[Long]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of references of the value associated with the specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of references of the value associated with the specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key</p></dd><dt>returns</dt><dd class="cmt"><p>the number of references or <code>None</code> if the key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.3
</p></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#pExpire" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pExpire(key:String,ttlMillis:Long):scala.concurrent.Future[Boolean]"></a>
      <a id="pExpire(String,Long):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pExpire</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="ttlMillis">ttlMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pExpire(key:String,ttlMillis:Long):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets a key's time to live in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttlMillis</dt><dd class="cmt"><p>time-to-live in milliseconds</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#pExpireAt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pExpireAt(key:String,timestampMillis:Long):scala.concurrent.Future[Boolean]"></a>
      <a id="pExpireAt(String,Long):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pExpireAt</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="timestampMillis">timestampMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pExpireAt(key:String,timestampMillis:Long):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the expiration for a key as a UNIX timestamp specified in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expiration for a key as a UNIX timestamp specified in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">timestampMillis</dt><dd class="cmt"><p>UNIX milliseconds-timestamp at which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#pSetEX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pSetEX[W](key:String,value:W,ttlMillis:Long)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="pSetEX[W](String,W,Long)(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pSetEX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.pSetEX.W">W</span></span>, <span name="ttlMillis">ttlMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.pSetEX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pSetEX[W](key:String,value:W,ttlMillis:Long)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the value and expiration in milliseconds of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration in milliseconds of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlMillis</dt><dd class="cmt"><p>time-to-live in milliseconds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#pTtl" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pTtl(key:String):scala.concurrent.Future[Either[Boolean,Long]]"></a>
      <a id="pTtl(String):Future[Either[Boolean,Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pTtl</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pTtl(key:String):scala.concurrent.Future[Either[Boolean,Long]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Gets the time to live for a key in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key in milliseconds.</p><pre>result <span class="kw">match</span> {
<span class="kw">case</span> Left(<span class="kw">false</span>) <span class="kw">=&gt;</span> <span class="cmt">// key does not exist</span>
<span class="kw">case</span> Left(<span class="kw">true</span>) <span class="kw">=&gt;</span> <span class="cmt">// key exists but has no associated expire</span>
<span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right(ttl)</code> where ttl is the time-to-live in milliseconds for specified key,
<code>Left(false)</code> if key does not exist or <code>Left(true)</code> if key exists but has no associated
expire
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>For <code>Redis</code> version &lt;= 2.8.x, <code>Left(false)</code> will be returned when the key does not
exists and when it exists but has no associated expire (<code>Redis</code> returns the same error code
for both cases). In other words, you can simply check the following</p><pre>result <span class="kw">match</span> {
<span class="kw">case</span> Left(_) <span class="kw">=&gt;</span>
<span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></span></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#passwordOpt" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="passwordOpt:Option[String]"></a>
      <a id="passwordOpt:Option[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">passwordOpt</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@passwordOpt:Option[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#persist" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="persist(key:String):scala.concurrent.Future[Boolean]"></a>
      <a id="persist(String):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">persist</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@persist(key:String):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes the expiration from a key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the expiration from a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to persist</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if key was persisted, <b>false</b> if key does not exist or does not have an
associated timeout
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd></dl></div>
    </li><li name="scredis.commands.HyperLogLogCommands#pfAdd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pfAdd[W](key:String,elements:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="pfAdd[W](String,W*)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pfAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="elements">elements: <span class="extype" name="scredis.commands.HyperLogLogCommands.pfAdd.W">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.HyperLogLogCommands.pfAdd.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pfAdd[W](key:String,elements:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Adds all the element arguments to the HyperLogLog data structure stored at specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Adds all the element arguments to the HyperLogLog data structure stored at specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key of the HyperLogLog data structure</p></dd><dt class="param">elements</dt><dd class="cmt"><p>element(s) to add to the HyperLogLog data structure</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if at least one HyperLogLog internal register was altered, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HyperLogLogCommands.html" class="extype" name="scredis.commands.HyperLogLogCommands">HyperLogLogCommands</a></dd><dt>Since</dt><dd><p>2.8.9
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key is not of HyperLogLog type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The HyperLogLog data structure can be used in order to count unique elements in a set
using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog
(plus a few bytes for the key itself).</p><p>The returned cardinality of the observed set is not exact, but approximated with a standard
error of 0.81%.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HyperLogLogCommands#pfCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pfCount(keys:String*):scala.concurrent.Future[Long]"></a>
      <a id="pfCount(String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pfCount</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pfCount(keys:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">When called with a single key, returns the approximated cardinality computed by the
HyperLogLog data structure stored at the specified variable, which is 0 if the variable
does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>When called with a single key, returns the approximated cardinality computed by the
HyperLogLog data structure stored at the specified variable, which is 0 if the variable
does not exist.</p><p>When called with multiple keys, returns the approximated cardinality of the union of the
HyperLogLogs passed, by internally merging the HyperLogLogs stored at the provided keys into
a temporary HyperLogLog.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>key(s) of the HyperLogLog data structure to count</p></dd><dt>returns</dt><dd class="cmt"><p>the approximate number of unique elements observed via PFADD</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HyperLogLogCommands.html" class="extype" name="scredis.commands.HyperLogLogCommands">HyperLogLogCommands</a></dd><dt>Since</dt><dd><p>2.8.9
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if at least one key is not of HyperLogLog type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The HyperLogLog data structure can be used in order to count unique elements in a set
using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog
(plus a few bytes for the key itself).</p><p>The returned cardinality of the observed set is not exact, but approximated with a standard
error of 0.81%.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.HyperLogLogCommands#pfMerge" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pfMerge(destKey:String,keys:String*):scala.concurrent.Future[Unit]"></a>
      <a id="pfMerge(String,String*):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pfMerge</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pfMerge(destKey:String,keys:String*):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Merge multiple HyperLogLog values into an unique value that will approximate the cardinality
of the union of the observed Sets of the source HyperLogLog structures.</p><div class="fullcomment"><div class="comment cmt"><p>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality
of the union of the observed Sets of the source HyperLogLog structures.</p><p>The computed merged HyperLogLog is set to the destination variable, which is created if does
not exist (defauling to an empty HyperLogLog).
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>the destination key where the result should be stored</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of the HyperLogLog data structure to merge</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/HyperLogLogCommands.html" class="extype" name="scredis.commands.HyperLogLogCommands">HyperLogLogCommands</a></dd><dt>Since</dt><dd><p>2.8.9
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if at least one key is not of HyperLogLog type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The HyperLogLog data structure can be used in order to count unique elements in a set
using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog
(plus a few bytes for the key itself).</p><p>The returned cardinality of the observed set is not exact, but approximated with a standard
error of 0.81%.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ConnectionCommands#ping" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ping():scala.concurrent.Future[String]"></a>
      <a id="ping():Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ping</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@ping():scala.concurrent.Future[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Pings the server.</p><div class="fullcomment"><div class="comment cmt"><p>Pings the server. This command is often used to test if a connection is still alive,
or to measure latency.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>PONG
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#port" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="port:Int"></a>
      <a id="port:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">port</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@port:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.PubSubCommands#pubSubChannels" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pubSubChannels(patternOpt:Option[String]):scala.concurrent.Future[List[String]]"></a>
      <a id="pubSubChannels(Option[String]):Future[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pubSubChannels</span><span class="params">(<span name="patternOpt">patternOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pubSubChannels(patternOpt:Option[String]):scala.concurrent.Future[List[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Lists the currently active channels.</p><div class="fullcomment"><div class="comment cmt"><p>Lists the currently active channels. An active channel is a Pub/Sub channel with one or more
subscribers (not including clients subscribed to patterns).
</p></div><dl class="paramcmts block"><dt class="param">patternOpt</dt><dd class="cmt"><p>optional pattern to filter returned channels</p></dd><dt>returns</dt><dd class="cmt"><p>the currently active channels, optionally matching the specified pattern
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If no pattern is specified, all the channels are listed, otherwise if pattern is
specified only channels matching the specified glob-style pattern are listed.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.PubSubCommands#pubSubNumPat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pubSubNumPat():scala.concurrent.Future[Long]"></a>
      <a id="pubSubNumPat():Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pubSubNumPat</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pubSubNumPat():scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of subscriptions to patterns (that are performed using the
PSUBSCRIBE command).</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of subscriptions to patterns (that are performed using the
PSUBSCRIBE command).
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the number of subscriptions to patterns
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>Note that this is not just the count of clients subscribed to patterns but the total
number of patterns all the clients are subscribed to.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.PubSubCommands#pubSubNumSub" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pubSubNumSub(channels:String*):scala.concurrent.Future[Map[String,Int]]"></a>
      <a id="pubSubNumSub(String*):Future[Map[String,Int]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pubSubNumSub</span><span class="params">(<span name="channels">channels: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@pubSubNumSub(channels:String*):scala.concurrent.Future[Map[String,Int]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of subscribers (not counting clients subscribed to patterns) for the
specified channels.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of subscribers (not counting clients subscribed to patterns) for the
specified channels.
</p></div><dl class="paramcmts block"><dt class="param">channels</dt><dd class="cmt"><p>channel name(s)</p></dd><dt>returns</dt><dd class="cmt"><p>a map of channels to number of subscribers for every provided channel
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd></dl></div>
    </li><li name="scredis.commands.PubSubCommands#publish" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="publish[W](channel:String,message:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="publish[W](String,W)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">publish</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="channel">channel: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="message">message: <span class="extype" name="scredis.commands.PubSubCommands.publish.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.PubSubCommands.publish.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@publish[W](channel:String,message:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Publishes a message to a channel.</p><div class="fullcomment"><div class="comment cmt"><p>Publishes a message to a channel.
</p></div><dl class="paramcmts block"><dt class="param">channel</dt><dd class="cmt"><p>the name of the channel</p></dd><dt class="param">message</dt><dd class="cmt"><p>the message payload</p></dd><dt>returns</dt><dd class="cmt"><p>the number of clients that received the message
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ConnectionCommands#quit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="quit():scala.concurrent.Future[Unit]"></a>
      <a id="quit():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">quit</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@quit():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Closes the connection.</p><div class="fullcomment"><div class="comment cmt"><p>Closes the connection.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#rPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPop[R](key:String)(implicitevidence$10:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="rPop[R](String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPop</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.ListCommands.rPop.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.ListCommands.rPop.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@rPop[R](key:String)(implicitevidence$10:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes and returns the last element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the last element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#rPopLPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPopLPush[R](sourceKey:String,destKey:String)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="rPopLPush[R](String,String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPopLPush</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="sourceKey">sourceKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.ListCommands.rPopLPush.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.ListCommands.rPopLPush.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@rPopLPush[R](sourceKey:String,destKey:String)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes the last element in a list, appends it to another list and returns it.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the last element in a list, appends it to another list and returns it.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of list to be pop from</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key of list to be push to</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#rPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPush[W](key:String,values:W*)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="rPush[W](String,W*)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPush</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="values">values: <span class="extype" name="scredis.commands.ListCommands.rPush.W">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.rPush.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@rPush[W](key:String,values:W*)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Appends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Appends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">values</dt><dd class="cmt"><p>value(s) to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ListCommands#rPushX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPushX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="rPushX[W](String,W)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPushX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.ListCommands.rPushX.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.ListCommands.rPushX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@rPushX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Appends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#randomKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="randomKey():scala.concurrent.Future[Option[String]]"></a>
      <a id="randomKey():Future[Option[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">randomKey</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@randomKey():scala.concurrent.Future[Option[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a random key from the keyspace.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random key from the keyspace.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the random key or <code>None</code> when the database is empty
associated timeout
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#receiveTimeoutOpt" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="receiveTimeoutOpt:Option[scala.concurrent.duration.FiniteDuration]"></a>
      <a id="receiveTimeoutOpt:Option[FiniteDuration]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">receiveTimeoutOpt</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@receiveTimeoutOpt:Option[scala.concurrent.duration.FiniteDuration]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#rename" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rename(key:String,newKey:String):scala.concurrent.Future[Unit]"></a>
      <a id="rename(String,String):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rename</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="newKey">newKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@rename(key:String,newKey:String):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Renames a key.</p><div class="fullcomment"><div class="comment cmt"><p>Renames a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>source key</p></dd><dt class="param">newKey</dt><dd class="cmt"><p>destination key</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the source and destination keys are the same, or when key
does not exist
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>if newKey already exists, it is overwritten</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#renameNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="renameNX(key:String,newKey:String):scala.concurrent.Future[Boolean]"></a>
      <a id="renameNX(String,String):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">renameNX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="newKey">newKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@renameNX(key:String,newKey:String):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Renames a key, only if the new key does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Renames a key, only if the new key does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>source key</p></dd><dt class="param">newKey</dt><dd class="cmt"><p>destination key</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if key was renamed to newKey, <b>false</b> if newKey already exists</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the source and destination keys are the same, or when key does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#restore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restore[W](key:String,serializedValue:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration])(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="restore[W](String,W,Option[FiniteDuration])(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">restore</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="serializedValue">serializedValue: <span class="extype" name="scredis.commands.KeyCommands.restore.W">W</span></span>, <span name="ttlOpt">ttlOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.KeyCommands.restore.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@restore[W](key:String,serializedValue:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration])(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Creates a key using the provided serialized value, previously obtained using DUMP.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a key using the provided serialized value, previously obtained using DUMP.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>destination key</p></dd><dt class="param">serializedValue</dt><dd class="cmt"><p>serialized value, previously obtained using DUMP</p></dd><dt class="param">ttlOpt</dt><dd class="cmt"><p>optional time-to-live duration of newly created key (expire)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the value could not be restored
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#role" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="role():scala.concurrent.Future[scredis.Role]"></a>
      <a id="role():Future[Role]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">role</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="package$$Role.html" class="extype" name="scredis.Role">Role</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@role():scala.concurrent.Future[scredis.Role]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Provides information on the role of a Redis instance in the context of replication,
by returing if the instance is currently a master, slave, or sentinel.</p><div class="fullcomment"><div class="comment cmt"><p>Provides information on the role of a Redis instance in the context of replication,
by returing if the instance is currently a master, slave, or sentinel.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the <a href="package$$Role.html" class="extype" name="scredis.Role">scredis.Role</a> of the <code>Redis</code> instance
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.8.12
</p></dd><dt>Note</dt><dd><span class="cmt"><p>The command also returns additional information about the state of the replication
(if the role is master or slave) or the list of monitored master names (if the role is
sentinel).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sAdd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sAdd[W](key:String,members:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="sAdd[W](String,W*)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="members">members: <span class="extype" name="scredis.commands.SetCommands.sAdd.W">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SetCommands.sAdd.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sAdd[W](key:String,members:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Adds one or more members to a set.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>member(s) to add</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members added to the set, not including all the members that were
already present</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sCard" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sCard(key:String):scala.concurrent.Future[Long]"></a>
      <a id="sCard(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sCard</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sCard(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of members in a set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of members in a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality (number of members) of the set, or 0 if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sDiff" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sDiff[R](key:String,keys:String*)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a>
      <a id="sDiff[R](String,String*)(Reader[R]):Future[Set[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sDiff</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sDiff.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.SetCommands.sDiff.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sDiff[R](key:String,keys:String*)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the set resulting from the difference between the first set and all the successive
sets.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the set resulting from the difference between the first set and all the successive
sets.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key of the first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>key(s) of successive set(s) whose members will be substracted from the first one</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if the first key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if some keys contain a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sDiffStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sDiffStore(destKey:String,key:String,keys:String*):scala.concurrent.Future[Long]"></a>
      <a id="sDiffStore(String,String,String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sDiffStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sDiffStore(destKey:String,key:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Stores the set resulting from the difference between the first set and all the successive sets.</p><div class="fullcomment"><div class="comment cmt"><p>Stores the set resulting from the difference between the first set and all the successive sets.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be substracted from first set, if empty, first set is simply
copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality of the resulting set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if some keys contain a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sInter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sInter[R](keys:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a>
      <a id="sInter[R](String*)(Reader[R]):Future[Set[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sInter</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sInter.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.SetCommands.sInter.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sInter[R](keys:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Intersects multiple sets.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sets.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be intersected together</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if the first key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if some keys contain a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sInterStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sInterStore(destKey:String,keys:String*):scala.concurrent.Future[Long]"></a>
      <a id="sInterStore(String,String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sInterStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sInterStore(destKey:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Intersects multiple sets and stores the resulting set in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sets and stores the resulting set in a key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be intersected together, if only one is specified, it is simply
copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality of the resulting set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if some keys contain a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sIsMember" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sIsMember[W](key:String,member:W)(implicitevidence$4:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="sIsMember[W](String,W)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sIsMember</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SetCommands.sIsMember.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SetCommands.sIsMember.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sIsMember[W](key:String,member:W)(implicitevidence$4:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Determines if a given value is a member of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a given value is a member of a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to be tested</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the provided value is a member of the set stored at key, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sMembers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sMembers[R](key:String)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a>
      <a id="sMembers[R](String)(Reader[R]):Future[Set[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sMembers</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sMembers.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.SetCommands.sMembers.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sMembers[R](key:String)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns all the members of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the members of a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>set stored at key, or the empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sMove" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sMove[W](sourceKey:String,destKey:String,member:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="sMove[W](String,String,W)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sMove</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="sourceKey">sourceKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SetCommands.sMove.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SetCommands.sMove.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sMove[W](sourceKey:String,destKey:String,member:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Moves a member from one set to another.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a member from one set to another.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of source set</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to be moved from source set to destination set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the member was moved, <b>false</b> if the element is not a member of source set and
no operation was performed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if sourceKey or destKey contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sPop[R](key:String)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="sPop[R](String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sPop</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sPop.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.SetCommands.sPop.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sPop[R](key:String)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes and returns a random member from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns a random member from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>random member, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This operation is similar to SRANDMEMBER, that returns a random element from a set but
does not remove it.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sRandMember" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sRandMember[R](key:String)(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a>
      <a id="sRandMember[R](String)(Reader[R]):Future[Option[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sRandMember</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sRandMember.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.SetCommands.sRandMember.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sRandMember[R](key:String)(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a random member from a set (without removing it).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random member from a set (without removing it).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>random member, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sRandMembers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sRandMembers[R](key:String,count:Int)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a>
      <a id="sRandMembers[R](String,Int)(Reader[R]):Future[Set[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sRandMembers</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sRandMembers.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.SetCommands.sRandMembers.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sRandMembers[R](key:String,count:Int)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a random member from a set (without removing it).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random member from a set (without removing it).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">count</dt><dd class="cmt"><p>number of member to randomly retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>set of random members, or the empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sRem[W](key:String,members:W*)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="sRem[W](String,W*)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sRem</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="members">members: <span class="extype" name="scredis.commands.SetCommands.sRem.W">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SetCommands.sRem.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sRem[W](key:String,members:W*)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes one or more members from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes one or more members from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>members to remove from set</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members that were removed from the set, not including non-existing
members</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Redis versions older than 2.4 can only remove one member per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sScan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,Set[R])]"></a>
      <a id="sScan[R](String,Long,Option[String],Option[Int])(Reader[R]):Future[(Long,Set[R])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="cursor">cursor: <span class="extype" name="scala.Long">Long</span></span>, <span name="matchOpt">matchOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sScan.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.SetCommands.sScan.R">R</span>])]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,Set[R])]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Incrementally iterates the elements of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates the elements of a set.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the set of elements
as its second element
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sUnion" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sUnion[R](keys:String*)(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a>
      <a id="sUnion[R](String*)(Reader[R]):Future[Set[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sUnion</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SetCommands.sUnion.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.SetCommands.sUnion.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sUnion[R](keys:String*)(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Computes the union of multiple sets.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sets.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be included in the union computation</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if the first key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if some keys contain a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SetCommands#sUnionStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sUnionStore(destKey:String,keys:String*):scala.concurrent.Future[Long]"></a>
      <a id="sUnionStore(String,String*):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sUnionStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sUnionStore(destKey:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Computes the union of multiple sets and stores the resulting set in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sets and stores the resulting set in a key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be included in the union computation, if only one is specified,
it is simply copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality of the resulting set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if some keys contain a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#save" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="save():scala.concurrent.Future[Unit]"></a>
      <a id="save():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">save</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@save():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Synchronously saves the dataset to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronously saves the dataset to disk.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#scan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scan(cursor:Long,matchOpt:Option[String],countOpt:Option[Int]):scala.concurrent.Future[(Long,Set[String])]"></a>
      <a id="scan(Long,Option[String],Option[Int]):Future[(Long,Set[String])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="params">(<span name="cursor">cursor: <span class="extype" name="scala.Long">Long</span></span>, <span name="matchOpt">matchOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>])]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@scan(cursor:Long,matchOpt:Option[String],countOpt:Option[Int]):scala.concurrent.Future[(Long,Set[String])]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Incrementally iterates the set of keys in the currently selected Redis database.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates the set of keys in the currently selected Redis database.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the set of keys
as its second element
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ScriptingCommands#scriptExists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptExists(sha1s:String*):scala.concurrent.Future[Map[String,Boolean]]"></a>
      <a id="scriptExists(String*):Future[Map[String,Boolean]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptExists</span><span class="params">(<span name="sha1s">sha1s: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@scriptExists(sha1s:String*):scala.concurrent.Future[Map[String,Boolean]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Checks existence of scripts in the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Checks existence of scripts in the script cache.
</p></div><dl class="paramcmts block"><dt class="param">sha1s</dt><dd class="cmt"><p>SHA1 digest(s) to check for existence</p></dd><dt>returns</dt><dd class="cmt"><p>SHA1 -&gt; Boolean <code>Map</code> where <b>true</b> means the script associated to the sha1 exists
in the cache
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ScriptingCommands#scriptFlush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptFlush():scala.concurrent.Future[Unit]"></a>
      <a id="scriptFlush():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptFlush</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@scriptFlush():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes all the scripts from the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all the scripts from the script cache.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ScriptingCommands#scriptKill" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptKill():scala.concurrent.Future[Unit]"></a>
      <a id="scriptKill():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptKill</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@scriptKill():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Kills the currently executing Lua script, assuming no write operation was yet performed by
the script.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the currently executing Lua script, assuming no write operation was yet performed by
the script.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If the script already performed write operations it can not be killed in this way
because it would violate Lua script atomicity contract. In such a case only SHUTDOWN NOSAVE
is able to kill the script, killing the Redis process in an hard way preventing it to persist
with half-written information.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ScriptingCommands#scriptLoad" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptLoad(script:String):scala.concurrent.Future[String]"></a>
      <a id="scriptLoad(String):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptLoad</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@scriptLoad(script:String):scala.concurrent.Future[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Loads or stores the specified Lua script into the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Loads or stores the specified Lua script into the script cache.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>the script to be loaded into the cache</p></dd><dt>returns</dt><dd class="cmt"><p>the SHA1 digest of the stored script</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if a compilation error occurs
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The script is guaranteed to stay in the script cache forever (unless SCRIPT FLUSH
is called).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ConnectionCommands#select" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="select(database:Int):scala.concurrent.Future[Unit]"></a>
      <a id="select(Int):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">select</span><span class="params">(<span name="database">database: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@select(database:Int):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Changes the selected database on the current connection.</p><div class="fullcomment"><div class="comment cmt"><p>Changes the selected database on the current connection.
</p></div><dl class="paramcmts block"><dt class="param">database</dt><dd class="cmt"><p>database index</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the database index is invalid
</p></span></dd></dl></div>
    </li><li name="scredis.io.AkkaNonBlockingConnection#send" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="send(transaction:scredis.Transaction):scala.concurrent.Future[Vector[scala.util.Try[Any]]]"></a>
      <a id="send(Transaction):Future[Vector[Try[Any]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">send</span><span class="params">(<span name="transaction">transaction: <span class="extype" name="scredis.Transaction">Transaction</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.util.Try">Try</span>[<span class="extype" name="scala.Any">Any</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@send(transaction:scredis.Transaction):scala.concurrent.Future[Vector[scala.util.Try[Any]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AkkaNonBlockingConnection.html" class="extype" name="scredis.io.AkkaNonBlockingConnection">AkkaNonBlockingConnection</a> → <a href="io/TransactionEnabledConnection.html" class="extype" name="scredis.io.TransactionEnabledConnection">TransactionEnabledConnection</a></dd></dl></div>
    </li><li name="scredis.io.AkkaNonBlockingConnection#send" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="send[A](request:scredis.protocol.Request[A]):scala.concurrent.Future[A]"></a>
      <a id="send[A](Request[A]):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">send</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="request">request: <a href="protocol/Request.html" class="extype" name="scredis.protocol.Request">Request</a>[<span class="extype" name="scredis.io.AkkaNonBlockingConnection.send.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.io.AkkaNonBlockingConnection.send.A">A</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@send[A](request:scredis.protocol.Request[A]):scala.concurrent.Future[A]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AkkaNonBlockingConnection.html" class="extype" name="scredis.io.AkkaNonBlockingConnection">AkkaNonBlockingConnection</a> → <a href="io/NonBlockingConnection.html" class="extype" name="scredis.io.NonBlockingConnection">NonBlockingConnection</a></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#set" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="set[W](key:String,value:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration],conditionOpt:Option[scredis.Condition])(implicitevidence$11:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="set[W](String,W,Option[FiniteDuration],Option[Condition])(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">set</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.set.W">W</span></span>, <span name="ttlOpt">ttlOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>] = <span class="symbol">None</span></span>, <span name="conditionOpt">conditionOpt: <span class="extype" name="scala.Option">Option</span>[<a href="package$$Condition.html" class="extype" name="scredis.Condition">Condition</a>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.set.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@set[W](key:String,value:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration],conditionOpt:Option[scredis.Condition])(implicitevidence$11:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the string value of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlOpt</dt><dd class="cmt"><p>optional time-to-live (up to milliseconds precision)</p></dd><dt class="param">conditionOpt</dt><dd class="cmt"><p>optional condition to be met for the value to be set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the value was set correctly, <b>false</b> if a condition was specified but not met
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type. Any previous
time to live associated with the key is discarded on successful SET operation.</p><p>The ttlOpt and conditionOpt parameters can only be used with <code>Redis</code> &gt;= 2.6.12
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#setBit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setBit(key:String,offset:Long,bit:Boolean):scala.concurrent.Future[Boolean]"></a>
      <a id="setBit(String,Long,Boolean):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setBit</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>, <span name="bit">bit: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@setBit(key:String,offset:Long,bit:Boolean):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets or clears the bit at offset in the string value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets or clears the bit at offset in the string value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key for which the bit should be set</p></dd><dt class="param">offset</dt><dd class="cmt"><p>position where the bit should be set</p></dd><dt class="param">bit</dt><dd class="cmt"><p><b>true</b> sets the bit to 1, <b>false</b> sets it to 0</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When key does not exist, a new string value is created. The string is grown to make sure
it can hold a bit at offset. When the string at key is grown, added bits are set to 0.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#setEX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setEX[W](key:String,value:W,ttlSeconds:Int)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a>
      <a id="setEX[W](String,W,Int)(Writer[W]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setEX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.setEX.W">W</span></span>, <span name="ttlSeconds">ttlSeconds: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.setEX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@setEX[W](key:String,value:W,ttlSeconds:Int)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the value and expiration in seconds of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration in seconds of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlSeconds</dt><dd class="cmt"><p>time-to-live in seconds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#setNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setNX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="setNX[W](String,W)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setNX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.setNX.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.setNX.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@setNX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sets the value of a key, only if the key does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of a key, only if the key does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the key was set, <b>false</b> otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#setRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setRange[W](key:String,offset:Long,value:W)(implicitevidence$14:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="setRange[W](String,Long,W)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setRange</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scredis.commands.StringCommands.setRange.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.StringCommands.setRange.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@setRange[W](key:String,offset:Long,value:W)(implicitevidence$14:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Overwrites part of a string at key starting at the specified offset.</p><div class="fullcomment"><div class="comment cmt"><p>Overwrites part of a string at key starting at the specified offset.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key</p></dd><dt class="param">offset</dt><dd class="cmt"><p>position from which the string must be overwritten</p></dd><dt class="param">value</dt><dd class="cmt"><p>string value to be set at given offset</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string after it was modified by the command</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the offset is larger than the current length of the string at key, the string is
padded with zero-bytes to make offset fit. Non-existing keys are considered as empty strings,
so this command will make sure it holds a string large enough to be able to set value at
offset.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#shutdown" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shutdown(modifierOpt:Option[scredis.ShutdownModifier]):scala.concurrent.Future[Unit]"></a>
      <a id="shutdown(Option[ShutdownModifier]):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shutdown</span><span class="params">(<span name="modifierOpt">modifierOpt: <span class="extype" name="scala.Option">Option</span>[<a href="package$$ShutdownModifier.html" class="extype" name="scredis.ShutdownModifier">ShutdownModifier</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@shutdown(modifierOpt:Option[scredis.ShutdownModifier]):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Gracefully shuts down a <code>Redis</code> server.</p><div class="fullcomment"><div class="comment cmt"><p>Gracefully shuts down a <code>Redis</code> server.
</p></div><dl class="paramcmts block"><dt class="param">modifierOpt</dt><dd class="cmt"><p>optional <a href="package$$ShutdownModifier.html" class="extype" name="scredis.ShutdownModifier">scredis.ShutdownModifier</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>The command performs the following operations:
- Stops all the clients
- Performs a blocking <code>SAVE</code> if at least one <b>save point</b> is configured
- Flushes the Append Only File if AOF is enabled
- Quits the server
</p></span></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#slaveOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="slaveOf(host:String,port:Int):scala.concurrent.Future[Unit]"></a>
      <a id="slaveOf(String,Int):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slaveOf</span><span class="params">(<span name="host">host: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="port">port: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@slaveOf(host:String,port:Int):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Configures the current <code>Redis</code> instance as a slave of another <code>Redis</code> instance.</p><div class="fullcomment"><div class="comment cmt"><p>Configures the current <code>Redis</code> instance as a slave of another <code>Redis</code> instance.
</p></div><dl class="paramcmts block"><dt class="param">host</dt><dd class="cmt"><p>the host of the master instance</p></dd><dt class="param">port</dt><dd class="cmt"><p>the port of the master instance
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#slaveOfNoOne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="slaveOfNoOne():scala.concurrent.Future[Unit]"></a>
      <a id="slaveOfNoOne():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slaveOfNoOne</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@slaveOfNoOne():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Breaks the replication of a slave <code>instance</code>, turning it back into a master instance.</p><div class="fullcomment"><div class="comment cmt"><p>Breaks the replication of a slave <code>instance</code>, turning it back into a master instance.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#slowLogGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="slowLogGet(countOpt:Option[Int]):scala.concurrent.Future[List[scredis.SlowLogEntry]]"></a>
      <a id="slowLogGet(Option[Int]):Future[List[SlowLogEntry]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slowLogGet</span><span class="params">(<span name="countOpt">countOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<a href="package$$SlowLogEntry.html" class="extype" name="scredis.SlowLogEntry">SlowLogEntry</a>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@slowLogGet(countOpt:Option[Int]):scala.concurrent.Future[List[scredis.SlowLogEntry]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Retieves entries from the slowlog.</p><div class="fullcomment"><div class="comment cmt"><p>Retieves entries from the slowlog.
</p></div><dl class="paramcmts block"><dt class="param">countOpt</dt><dd class="cmt"><p>optionally limits the number of retrieved entries</p></dd><dt>returns</dt><dd class="cmt"><p>list of slowlog entries
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.2.12
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#slowLogLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="slowLogLen():scala.concurrent.Future[Long]"></a>
      <a id="slowLogLen():Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slowLogLen</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@slowLogLen():scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of entries in the slowlog.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of entries in the slowlog.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>number of entries in the slowlog
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.2.12
</p></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#slowLogReset" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="slowLogReset():scala.concurrent.Future[Unit]"></a>
      <a id="slowLogReset():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slowLogReset</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@slowLogReset():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Resets the slowlog.</p><div class="fullcomment"><div class="comment cmt"><p>Resets the slowlog.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.2.12
</p></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#sort" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sort[R](key:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Traversable[String],desc:Boolean,alpha:Boolean)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]"></a>
      <a id="sort[R](String,Option[String],Option[(Long,Long)],Traversable[String],Boolean,Boolean)(Reader[R]):Future[List[Option[R]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sort</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="byOpt">byOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>, <span name="get">get: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">Nil</span></span>, <span name="desc">desc: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.KeyCommands.sort.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.KeyCommands.sort.R">R</span>]]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sort[R](key:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Traversable[String],desc:Boolean,alpha:Boolean)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sorts the elements of a list, set or sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Sorts the elements of a list, set or sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">byOpt</dt><dd class="cmt"><p>optional pattern for sorting by external values, can also be &quot;nosort&quot; if
the sorting operation should be skipped (useful when only sorting to retrieve objects
with get). The * gets replaced by the values of the elements in the collection</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional pair of numbers (offset, count) where offset specified the number of
elements to skip and count specifies the number of elements to return starting from offset</p></dd><dt class="param">get</dt><dd class="cmt"><p>list of patterns for retrieving objects stored in external keys. The * gets
replaced by the values of the elements in the collection</p></dd><dt class="param">desc</dt><dd class="cmt"><p>indicates whether elements should be sorted descendingly</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>indicates whether elements should be sorted lexicographically</p></dd><dt>returns</dt><dd class="cmt"><p>the sorted list of elements, or the empty list if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>whenever an error occurs
</p></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#sortAndStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sortAndStore(key:String,targetKey:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Traversable[String],desc:Boolean,alpha:Boolean):scala.concurrent.Future[Long]"></a>
      <a id="sortAndStore(String,String,Option[String],Option[(Long,Long)],Traversable[String],Boolean,Boolean):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortAndStore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="targetKey">targetKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="byOpt">byOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>, <span name="get">get: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">Nil</span></span>, <span name="desc">desc: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@sortAndStore(key:String,targetKey:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Traversable[String],desc:Boolean,alpha:Boolean):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Sorts the elements of a list, set or sorted set and then store the result.</p><div class="fullcomment"><div class="comment cmt"><p>Sorts the elements of a list, set or sorted set and then store the result.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">targetKey</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">byOpt</dt><dd class="cmt"><p>optional pattern for sorting by external values, can also be &quot;nosort&quot; if
the sorting operation should be skipped (useful when only sorting to retrieve objects
with get). The * gets replaced by the values of the elements in the collection</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional pair of numbers (offset, count) where offset specified the
number of elements to skip and count specifies the number of elements to return starting
from offset</p></dd><dt class="param">get</dt><dd class="cmt"><p>list of patterns for retrieving objects stored in external keys. The * gets
replaced by the values of the elements in the collection</p></dd><dt class="param">desc</dt><dd class="cmt"><p>indicates whether elements should be sorted descendingly</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>indicates whether elements should be sorted lexicographically</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the newly stored sorted collection</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>whenever an error occurs
</p></span></dd></dl></div>
    </li><li name="scredis.commands.StringCommands#strLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="strLen(key:String):scala.concurrent.Future[Long]"></a>
      <a id="strLen(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">strLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@strLen(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the length of the string value stored in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of the string value stored in a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string stored at key, or 0 when the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if the key contains a value of the wrong type
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@synchronized[T0](x$1:=&gt;T0):T0" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#system" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="system:akka.actor.ActorSystem"></a>
      <a id="system:ActorSystem"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">system</span><span class="result">: <span class="extype" name="akka.actor.ActorSystem">ActorSystem</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@system:akka.actor.ActorSystem" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#tcpReceiveBufferSizeHint" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tcpReceiveBufferSizeHint:Int"></a>
      <a id="tcpReceiveBufferSizeHint:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">tcpReceiveBufferSizeHint</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@tcpReceiveBufferSizeHint:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#tcpSendBufferSizeHint" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tcpSendBufferSizeHint:Int"></a>
      <a id="tcpSendBufferSizeHint:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">tcpSendBufferSizeHint</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@tcpSendBufferSizeHint:Int" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scredis.commands.ServerCommands#time" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="time():scala.concurrent.Future[(Long,Long)]"></a>
      <a id="time():Future[(Long,Long)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">time</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@time():scala.concurrent.Future[(Long,Long)]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the current server time.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the current server time.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>pair of longs containing (1) UNIX timestamp and (2) microseconds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@toString():String" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#ttl" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ttl(key:String):scala.concurrent.Future[Either[Boolean,Int]]"></a>
      <a id="ttl(String):Future[Either[Boolean,Int]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ttl</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@ttl(key:String):scala.concurrent.Future[Either[Boolean,Int]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Gets the time to live for a key in seconds.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key in seconds.</p><pre>result <span class="kw">match</span> {
<span class="kw">case</span> Left(<span class="kw">false</span>) <span class="kw">=&gt;</span> <span class="cmt">// key does not exist</span>
<span class="kw">case</span> Left(<span class="kw">true</span>) <span class="kw">=&gt;</span> <span class="cmt">// key exists but has no associated expire</span>
<span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right(ttl)</code> where ttl is the time-to-live in seconds for specified key,
<code>Left(false)</code> if key does not exist or <code>Left(true)</code> if key exists but has no associated
expire
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>For <code>Redis</code> version &lt;= 2.8.x, <code>Left(false)</code> will be returned when the key does not
exists and when it exists but has no associated expire (<code>Redis</code> returns the same error code
for both cases). In other words, you can simply check the following</p><pre>result <span class="kw">match</span> {
<span class="kw">case</span> Left(_) <span class="kw">=&gt;</span>
<span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></span></dd></dl></div>
    </li><li name="scredis.commands.KeyCommands#type" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="type(key:String):scala.concurrent.Future[Option[scredis.Type]]"></a>
      <a id="type(String):Future[Option[Type]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">type</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<a href="package$$Type.html" class="extype" name="scredis.Type">Type</a>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@type(key:String):scala.concurrent.Future[Option[scredis.Type]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Determine the type stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Determine the type stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key for which the type should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>type of key, or <code>None</code> if key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>This method needs to be called as follows:</p><pre>client.`<span class="kw">type</span>`(key)</pre></span></dd></dl></div>
    </li><li name="scredis.commands.TransactionCommands#unwatch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unwatch():scala.concurrent.Future[Unit]"></a>
      <a id="unwatch():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unwatch</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@unwatch():scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Forgets about all watched keys.</p><div class="fullcomment"><div class="comment cmt"><p>Forgets about all watched keys.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd></dl></div>
    </li><li name="scredis.io.AbstractAkkaConnection#updateState" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="updateState(request:scredis.protocol.Request[_]):Unit"></a>
      <a id="updateState(Request[_]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">updateState</span><span class="params">(<span name="request">request: <a href="protocol/Request.html" class="extype" name="scredis.protocol.Request">Request</a>[_]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@updateState(request:scredis.protocol.Request[_]):Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@wait():Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@wait(x$1:Long,x$2:Int):Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@wait(x$1:Long):Unit" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scredis.commands.TransactionCommands#watch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="watch(keys:String*):scala.concurrent.Future[Unit]"></a>
      <a id="watch(String*):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">watch</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@watch(keys:String*):scala.concurrent.Future[Unit]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Watches the given keys, which upon modification, will abort a transaction.</p><div class="fullcomment"><div class="comment cmt"><p>Watches the given keys, which upon modification, will abort a transaction.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>keys to watch
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd></dl></div>
    </li><li name="scredis.commands.TransactionCommands#withTransaction" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withTransaction[A](f:scredis.TransactionBuilder=&gt;A):A"></a>
      <a id="withTransaction[A]((TransactionBuilder)⇒A):A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withTransaction</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="TransactionBuilder.html" class="extype" name="scredis.TransactionBuilder">TransactionBuilder</a>) ⇒ <span class="extype" name="scredis.commands.TransactionCommands.withTransaction.A">A</span></span>)</span><span class="result">: <span class="extype" name="scredis.commands.TransactionCommands.withTransaction.A">A</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@withTransaction[A](f:scredis.TransactionBuilder=&gt;A):A" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zAdd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zAdd[W](key:String,members:Map[W,scredis.Score])(implicitevidence$2:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="zAdd[W](String,Map[W,Score])(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="members">members: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scredis.commands.SortedSetCommands.zAdd.W">W</span>, <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zAdd.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zAdd[W](key:String,members:Map[W,scredis.Score])(implicitevidence$2:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Adds one or more members to a sorted set, or update its score if it already exists.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a sorted set, or update its score if it already exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>member-score pairs to be added</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements added to the sorted sets, not including elements already
existing for which the score was updated</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.4
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If a specified member is already a member of the sorted set, the score is updated and
the element reinserted at the right position to ensure the correct ordering.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zAdd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zAdd[W](key:String,member:W,score:scredis.Score)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a>
      <a id="zAdd[W](String,W,Score)(Writer[W]):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SortedSetCommands.zAdd.W">W</span></span>, <span name="score">score: <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zAdd.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zAdd[W](key:String,member:W,score:scredis.Score)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Adds a member to a sorted set, or update its score if it already exists.</p><div class="fullcomment"><div class="comment cmt"><p>Adds a member to a sorted set, or update its score if it already exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>member to add</p></dd><dt class="param">score</dt><dd class="cmt"><p>score of the member to add</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the member was added, or <b>false</b> if the member already exists</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If a specified member is already a member of the sorted set, the score is updated and
the element reinserted at the right position to ensure the correct ordering.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zCard" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zCard(key:String):scala.concurrent.Future[Long]"></a>
      <a id="zCard(String):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zCard</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zCard(key:String):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of members in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of members in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality (number of elements) of the sorted set, or 0 if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zCount(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]"></a>
      <a id="zCount(String,ScoreLimit,ScoreLimit):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zCount</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zCount(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of elements of a sorted set belonging to a given score range.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of elements of a sorted set belonging to a given score range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the specified score range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zIncrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zIncrBy[W](key:String,member:W,increment:Double)(implicitevidence$3:scredis.serialization.Writer[W]):scala.concurrent.Future[Double]"></a>
      <a id="zIncrBy[W](String,W,Double)(Writer[W]):Future[Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zIncrBy</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SortedSetCommands.zIncrBy.W">W</span></span>, <span name="increment">increment: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zIncrBy.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zIncrBy[W](key:String,member:W,increment:Double)(implicitevidence$3:scredis.serialization.Writer[W]):scala.concurrent.Future[Double]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Increments the score of a member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the score of a member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>member whose score needs to be incremented</p></dd><dt class="param">increment</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the new score of member</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zInterStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zInterStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a>
      <a id="zInterStore(String,Seq[String],Aggregate):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zInterStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zInterStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Intersects multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sorted sets to intersect</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zInterStoreWeighted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zInterStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a>
      <a id="zInterStoreWeighted(String,Map[String,Double],Aggregate):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zInterStoreWeighted</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keysWeightPairs">keysWeightPairs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Double">Double</span>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zInterStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Intersects multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keysWeightPairs</dt><dd class="cmt"><p>key to weight pairs</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zLexCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zLexCount(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]"></a>
      <a id="zLexCount(String,LexicalScoreLimit,LexicalScoreLimit):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zLexCount</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$LexicalScoreLimit.html" class="extype" name="scredis.LexicalScoreLimit">LexicalScoreLimit</a></span>, <span name="max">max: <a href="package$$LexicalScoreLimit.html" class="extype" name="scredis.LexicalScoreLimit">LexicalScoreLimit</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zLexCount(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the number of elements of a sorted set belonging to a given lexical score range.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of elements of a sorted set belonging to a given lexical score range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>lexical score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>lexical score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the specified lexical score range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.9
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Lexical ordering only applies when all the elements in a sorted set are inserted
with the same score
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRange[R](key:String,start:Long,stop:Long)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a>
      <a id="zRange[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRange.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRange.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRange[R](key:String,start:Long,stop:Long)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified range, or the empty set if
key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next
element and so on. They can also be negative numbers indicating offsets from the end of the
sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and
so on. Out of range indexes will not produce an error. If start is larger than the largest
index in the sorted set, or <code>start</code> &gt; <code>end</code>, an empty list is returned. If <code>end</code> is larger
than the end of the sorted set Redis will treat it like it is the last element of the
sorted set. The indexes are inclusive.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRangeByLex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeByLex[R](key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a>
      <a id="zRangeByLex[R](String,LexicalScoreLimit,LexicalScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeByLex</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$LexicalScoreLimit.html" class="extype" name="scredis.LexicalScoreLimit">LexicalScoreLimit</a></span>, <span name="max">max: <a href="package$$LexicalScoreLimit.html" class="extype" name="scredis.LexicalScoreLimit">LexicalScoreLimit</a></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Int">Int</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRangeByLex.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRangeByLex.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRangeByLex[R](key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by lexical score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by lexical score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>lexical score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>lexical score upper bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified lexical range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.9
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Lexical ordering only applies when all the elements in a sorted set are inserted
with the same score
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRangeByScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeByScore[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a>
      <a id="zRangeByScore[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeByScore</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Int">Int</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRangeByScore.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRangeByScore.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRangeByScore[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified score range, or the empty set
if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The elements having the same score are returned in lexicographical order (this follows
from a property of the sorted set implementation in Redis and does not involve further
computation).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRangeByScoreWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeByScoreWithScores[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a>
      <a id="zRangeByScoreWithScores[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeByScoreWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Int">Int</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRangeByScoreWithScores.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.SortedSetCommands.zRangeByScoreWithScores.R">R</span>, <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>)]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRangeByScoreWithScores[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members with associated scores in a sorted set, by score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members with associated scores in a sorted set, by score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered element-score pairs in the specified score range, or
the empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The elements having the same score are returned in lexicographical order (this follows
from a property of the sorted set implementation in Redis and does not involve further
computation).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRangeWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a>
      <a id="zRangeWithScores[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRangeWithScores.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.SortedSetCommands.zRangeWithScores.R">R</span>, <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>)]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members with associated scores in a sorted set, by index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members with associated scores in a sorted set, by index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements-score pairs in the specified range, or the
empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next
element and so on. They can also be negative numbers indicating offsets from the end of the
sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and
so on. Out of range indexes will not produce an error. If start is larger than the largest
index in the sorted set, or <code>start</code> &gt; <code>end</code>, an empty list is returned. If <code>end</code> is larger
than the end of the sorted set Redis will treat it like it is the last element of the
sorted set. The indexes are inclusive.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRank[W](key:String,member:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]"></a>
      <a id="zRank[W](String,W)(Writer[W]):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRank</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SortedSetCommands.zRank.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRank.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRank[W](key:String,member:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Determines the index of a member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Determines the index of a member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the rank or index of the member, or <code>None</code> if the member is not in the set or the key
does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRem[W](key:String,members:W*)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a>
      <a id="zRem[W](String,W*)(Writer[W]):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRem</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="members">members: <span class="extype" name="scredis.commands.SortedSetCommands.zRem.W">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRem.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRem[W](key:String,members:W*)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes one or more members from a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes one or more members from a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>additional values to be removed (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed from the sorted set, not including non existing members</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Redis versions older than 2.4 can only remove one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRemRangeByLex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRemRangeByLex(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]"></a>
      <a id="zRemRangeByLex(String,LexicalScoreLimit,LexicalScoreLimit):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRemRangeByLex</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$LexicalScoreLimit.html" class="extype" name="scredis.LexicalScoreLimit">LexicalScoreLimit</a></span>, <span name="max">max: <a href="package$$LexicalScoreLimit.html" class="extype" name="scredis.LexicalScoreLimit">LexicalScoreLimit</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRemRangeByLex(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes all members in a sorted set within the given lexical range.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given lexical range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>lexical score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>lexical score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of removed elements</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.9
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Lexical ordering only applies when all the elements in a sorted set are inserted
with the same score
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRemRangeByRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRemRangeByRank(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]"></a>
      <a id="zRemRangeByRank(String,Long,Long):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRemRangeByRank</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRemRangeByRank(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes all members in a sorted set within the given indexes.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given indexes.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset or index (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>the stop offset or index (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based inclusive indexes with 0 being the element with the
lowest score. These indexes can be negative numbers, where they indicate offsets starting at
the element with the highest score. For example: -1 is the element with the highest score, -2
the element with the second highest score and so forth.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRemRangeByScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRemRangeByScore(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]"></a>
      <a id="zRemRangeByScore(String,ScoreLimit,ScoreLimit):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRemRangeByScore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRemRangeByScore(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Removes all members in a sorted set within the given scores range.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given scores range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Since version 2.1.6, min and max can be exclusive, following the syntax of ZRANGEBYSCORE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRevRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRange[R](key:String,start:Long,stop:Long)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a>
      <a id="zRevRange[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRange.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRange.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRevRange[R](key:String,start:Long,stop:Long)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by index, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified range, or the empty set if
key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGE is similar to ZRANGE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRevRangeByScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRangeByScore[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$13:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a>
      <a id="zRevRangeByScore[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRangeByScore</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="max">max: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="min">min: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Int">Int</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRangeByScore.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRangeByScore.R">R</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRevRangeByScore[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$13:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by score, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by score, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified score range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGEBYSCORE is similar to ZRANGEBYSCORE. The
elements having the same score are returned in reverse lexicographical order.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRevRangeByScoreWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRangeByScoreWithScores[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$14:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a>
      <a id="zRevRangeByScoreWithScores[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRangeByScoreWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="max">max: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="min">min: <a href="package$$ScoreLimit.html" class="extype" name="scredis.ScoreLimit">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Int">Int</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRangeByScoreWithScores.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.SortedSetCommands.zRevRangeByScoreWithScores.R">R</span>, <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>)]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRevRangeByScoreWithScores[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$14:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Return a range of members with associated scores in a sorted set, by score, with scores
ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Return a range of members with associated scores in a sorted set, by score, with scores
ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified score range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGEBYSCORE is similar to ZRANGEBYSCORE. The
elements having the same score are returned in reverse lexicographical order.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRevRangeWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a>
      <a id="zRevRangeWithScores[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRangeWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="stop">stop: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRangeWithScores.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.SortedSetCommands.zRevRangeWithScores.R">R</span>, <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>)]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRevRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by index, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements-score pairs in the specified range, or the
empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGE is similar to ZRANGE. The elements having
the same score are returned in reverse lexicographical order.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zRevRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRank[W](key:String,member:W)(implicitevidence$15:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]"></a>
      <a id="zRevRank[W](String,W)(Writer[W]):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRank</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SortedSetCommands.zRevRank.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zRevRank.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zRevRank[W](key:String,member:W)(implicitevidence$15:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Determine the index of a member in a sorted set, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Determine the index of a member in a sorted set, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the rank or index of the member, or <code>None</code> if the member is not in the set or the key
does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zScan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$16:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,scredis.util.LinkedHashSet[(R,scredis.Score)])]"></a>
      <a id="zScan[R](String,Long,Option[String],Option[Int])(Reader[R]):Future[(Long,LinkedHashSet[(R,Score)])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="cursor">cursor: <span class="extype" name="scala.Long">Long</span></span>, <span name="matchOpt">matchOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" class="extype" name="scredis.serialization.Reader">Reader</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zScan.R">R</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[(<span class="extype" name="scala.Long">Long</span>, <a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.SortedSetCommands.zScan.R">R</span>, <a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>)])]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$16:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,scredis.util.LinkedHashSet[(R,scredis.Score)])]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Incrementally iterates the elements (value-score pairs) of a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates the elements (value-score pairs) of a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the sorted set of
elements (value-score pairs) as its second element
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.0
</p></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zScore[W](key:String,member:W)(implicitevidence$17:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[scredis.Score]]"></a>
      <a id="zScore[W](String,W)(Writer[W]):Future[Option[Score]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zScore</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scredis.commands.SortedSetCommands.zScore.W">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" class="extype" name="scredis.serialization.Writer">Writer</a>[<span class="extype" name="scredis.commands.SortedSetCommands.zScore.W">W</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<a href="package$$Score.html" class="extype" name="scredis.Score">Score</a>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zScore[W](key:String,member:W)(implicitevidence$17:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[scredis.Score]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the score associated with the given member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the score associated with the given member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the score of member, or <code>None</code> if the latter is not in the sorted set or the key does
not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zUnionStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zUnionStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a>
      <a id="zUnionStore(String,Seq[String],Aggregate):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zUnionStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zUnionStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sorted sets</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.SortedSetCommands#zUnionStoreWeighted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zUnionStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a>
      <a id="zUnionStoreWeighted(String,Map[String,Double],Aggregate):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zUnionStoreWeighted</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keysWeightPairs">keysWeightPairs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Double">Double</span>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#scredis.Client@zUnionStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisErrorResponseException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scredis.commands.TransactionCommands">
              <h3>Inherited from <a href="commands/TransactionCommands.html" class="extype" name="scredis.commands.TransactionCommands">TransactionCommands</a></h3>
            </div><div class="parent" name="scredis.commands.PubSubCommands">
              <h3>Inherited from <a href="commands/PubSubCommands.html" class="extype" name="scredis.commands.PubSubCommands">PubSubCommands</a></h3>
            </div><div class="parent" name="scredis.commands.HyperLogLogCommands">
              <h3>Inherited from <a href="commands/HyperLogLogCommands.html" class="extype" name="scredis.commands.HyperLogLogCommands">HyperLogLogCommands</a></h3>
            </div><div class="parent" name="scredis.commands.ScriptingCommands">
              <h3>Inherited from <a href="commands/ScriptingCommands.html" class="extype" name="scredis.commands.ScriptingCommands">ScriptingCommands</a></h3>
            </div><div class="parent" name="scredis.commands.SortedSetCommands">
              <h3>Inherited from <a href="commands/SortedSetCommands.html" class="extype" name="scredis.commands.SortedSetCommands">SortedSetCommands</a></h3>
            </div><div class="parent" name="scredis.commands.SetCommands">
              <h3>Inherited from <a href="commands/SetCommands.html" class="extype" name="scredis.commands.SetCommands">SetCommands</a></h3>
            </div><div class="parent" name="scredis.commands.ListCommands">
              <h3>Inherited from <a href="commands/ListCommands.html" class="extype" name="scredis.commands.ListCommands">ListCommands</a></h3>
            </div><div class="parent" name="scredis.commands.HashCommands">
              <h3>Inherited from <a href="commands/HashCommands.html" class="extype" name="scredis.commands.HashCommands">HashCommands</a></h3>
            </div><div class="parent" name="scredis.commands.StringCommands">
              <h3>Inherited from <a href="commands/StringCommands.html" class="extype" name="scredis.commands.StringCommands">StringCommands</a></h3>
            </div><div class="parent" name="scredis.commands.KeyCommands">
              <h3>Inherited from <a href="commands/KeyCommands.html" class="extype" name="scredis.commands.KeyCommands">KeyCommands</a></h3>
            </div><div class="parent" name="scredis.commands.ServerCommands">
              <h3>Inherited from <a href="commands/ServerCommands.html" class="extype" name="scredis.commands.ServerCommands">ServerCommands</a></h3>
            </div><div class="parent" name="scredis.commands.ConnectionCommands">
              <h3>Inherited from <a href="commands/ConnectionCommands.html" class="extype" name="scredis.commands.ConnectionCommands">ConnectionCommands</a></h3>
            </div><div class="parent" name="scredis.io.AkkaNonBlockingConnection">
              <h3>Inherited from <a href="io/AkkaNonBlockingConnection.html" class="extype" name="scredis.io.AkkaNonBlockingConnection">AkkaNonBlockingConnection</a></h3>
            </div><div class="parent" name="scredis.io.TransactionEnabledConnection">
              <h3>Inherited from <a href="io/TransactionEnabledConnection.html" class="extype" name="scredis.io.TransactionEnabledConnection">TransactionEnabledConnection</a></h3>
            </div><div class="parent" name="scredis.io.NonBlockingConnection">
              <h3>Inherited from <a href="io/NonBlockingConnection.html" class="extype" name="scredis.io.NonBlockingConnection">NonBlockingConnection</a></h3>
            </div><div class="parent" name="scredis.io.AbstractAkkaConnection">
              <h3>Inherited from <a href="io/AbstractAkkaConnection.html" class="extype" name="scredis.io.AbstractAkkaConnection">AbstractAkkaConnection</a></h3>
            </div><div class="parent" name="com.typesafe.scalalogging.slf4j.LazyLogging">
              <h3>Inherited from <span class="extype" name="com.typesafe.scalalogging.slf4j.LazyLogging">LazyLogging</span></h3>
            </div><div class="parent" name="com.typesafe.scalalogging.Logging">
              <h3>Inherited from <span class="extype" name="com.typesafe.scalalogging.Logging">Logging</span></h3>
            </div><div class="parent" name="scredis.io.Connection">
              <h3>Inherited from <a href="io/Connection.html" class="extype" name="scredis.io.Connection">Connection</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>